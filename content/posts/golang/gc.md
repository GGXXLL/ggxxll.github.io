---
title: 'Gc'
tags:
date: '2022-11-11'
categories:
draft: true
---

### 常见垃圾回收机制

#### 引用计数

对每个对象维护一个引用计数，当引用对象的对象被销毁时，引用计数-1，如果引用计数为0，则进行垃圾回收
- 优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。
- 缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。
- 代表语言：Python、PHP、Swift

#### 标记-清除
从根变量开始遍历所有引用的对象，引用的对象标记为"被引用"，没有被标记的进行回收。

- 优点：解决了引用计数的缺点。
- 缺点：需要STW，即要暂时停掉程序运行。
- 代表语言：Golang(其采用三色标记法)
#### 分代收集
按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。

- 优点：回收性能好
- 缺点：算法复杂
- 代表语言： JAVA

### 三色标记法

- 灰色：对象已被标记，但这个对象包含的子对象未标记
- 黑色：对象已被标记，且这个对象包含的子对象也已标记，gcmarkBits 对应的位为1（该对象不会在本次GC中被清理）
- 白色：对象未被标记，gcmarkBits 对应的位为0（该对象将会在本次GC中被清理）

#### 标记过程：

- 起初所有的对象都是白色的；
- 从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；
- 从待处理队列中取出灰色对象，将其引用的对象标记为灰色并放入待处理队列中，自身标记为黑色；
- 重复步骤3，直到待处理队列为空，此时白色对象即为不可达的“垃圾”，回收白色对象；

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象。

根对象包括：

- 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
- 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
- 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

#### 触发机制

- 阈值：默认内存扩大一倍，启动gc
- 定期：默认2min触发一次gc
- 手动：`runtime.GC()`

### STW

Stop The World 是 gc 的最大性能问题，对于 go 而言，需要停止所有的内存变化，即停止所有的 goroutine，等待 gc 结束之后才恢复。

标记-清除 (mark and sweep) 算法的 STW(stop the world)操作，就是 runtime 把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。

### GC 流程

1. Sweep Termination: 对未清扫的 span 进行清扫, 只有上一轮的 GC 的清扫工作完成才可以开始新一轮的 GC
2. Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收
3. Mark Termination: 完成标记工作, 重新扫描部分根对象(要求 STW )
4. Sweep: 按标记结果清扫 span

目前整个 GC 流程会进行两次 STW(Stop The World), 第一次是 Mark 阶段的开始, 第二次是 Mark Termination 阶段.

- 第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助 GC(mutator assist).
- 第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助 GC(mutator assist).

需要注意的是, 不是所有根对象的扫描都需要 STW, 例如扫描栈上的对象只需要停止拥有该栈的 G.

从 go1.9 开始, 写屏障的实现使用了 `Hybrid Write Barrier`, 大幅减少了第二次 STW 的时间.


### 写屏障

写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。
通俗的讲：就是在 gc 跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的 stw，然后对对象进行标记)
