---
title:  ACID
tags:
  - Mysql
date: 2022-10-23
categories:
  - 数据库
---

### 概述

ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：
原子性（atomicity [ˌætəˈmɪsəti]， 或称不可分割性）、一致性（consistency [kənˈsɪstənsi]）、
隔离性（isolation [ˌaɪsəˈleɪʃn]，又称独立性）、持久性（durability [ˌdjʊərəˈbɪlɪti]）。

在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。

### 特性

- Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read
  uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 事务并发时可能出现的问题

#### 脏读（Dirty Read）

A 事务读到了 B 未提交事务修改过的数据

#### 不可重复读（Non-Repeatable Read）

A 事务只能读到 B 已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，A 事务都能查询得到最新值。
（不可重复读在读未提交和读已提交隔离级别都可能会出现）

#### 幻读（Phantom）

A 事务先根据某些条件查询出一些记录，之后 B 事务又向表中插入了符合这些条件的记录，A 事务再次按照该条件查询时，能把 B 事务插入的记录也读出来。
（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）

### Mysql事务的隔离级别

MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。

MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。

隔离级别比较：可串行化 > 可重复读 > 读已提交 > 读未提交

隔离级别对性能的影响比较：可串行化 > 可重复读 > 读已提交 > 读未提交

由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL Innodb默认的隔离级别也是可重复读。

#### 读未提交（READ UNCOMMITTED）
在读未提交隔离级别下，事务 A 可以读取到事务 B 修改过但未提交的数据。

可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。
#### 读已提交（READ COMMITTED）
在读已提交隔离级别下，事务 A 只能在事务 B 修改过并且已提交后才能读取到事务 B 修改的数据。  

读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。


1. 普通读是快照读；
2. 加锁的select, update, delete等语句，除了在外键约束检查(foreign-key constraint checking)以及重复键检查(duplicate-key checking)时会封锁区间，其他时刻都只使用记录锁；

#### 可重复读（REPEATABLE READ）
在可重复读隔离级别下，事务 A 只能在事务 B 修改过数据并提交后，A 也提交事务后，才能读取到事务 B 修改的数据。

可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。

> 提问：为什么上了写锁（写操作），别的事务还可以读操作？

因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。

1. 普通的select使用快照读(snapshot read)，这是一种不加锁的一致性读(Consistent Nonlocking Read)，底层使用MVCC来实现，具体的原理在《InnoDB并发如此高，原因竟然在这？》中有详细的描述；
2. 加锁的select(`select ... in share mode` | `select ... for update`), update, delete等语句，它们的锁，依赖于它们是否在唯一索引(unique index)上使用了唯一的查询条件(unique search condition)，或者范围查询条件(range-type search condition)：
- 在唯一索引上使用唯一的查询条件，会使用记录锁(record lock)，而不会封锁记录之间的间隔，即不会使用间隙锁(gap lock)与临键锁(next-key lock)
- 范围查询条件，会使用间隙锁与临键锁，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录，以及避免不可重复的读

#### 可串行化（SERIALIZABLE）
各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。
事务并发执行时，阻塞情况与读写锁相同，可同时读，不可以读写交叉。

所有select语句都会被隐式的转化为 `select ... in share mode`.

### 隔离级别比较

| 级别 | 脏读 | 不可重复读 | 幻读  |
|------|---|----|-----|
| 读未提交 | 可能 | 可能 | 可能  |
| 读已提交 | 不会 | 可能 | 可能  |
| 可重复读 | 不会 | 不会 | 可能  |
| 串行读 | 不会 | 不会 | 不会  |

### 隔离级别的实现原理

使用MySQL的默认隔离级别（可重复读）来进行说明。

每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。
即通过回滚（rollback操作），可以回到前一个状态的值。

提问：回滚操作日志（undo log）什么时候删除？

MySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。

提问：什么时候不需要了？

当系统里么有比这个回滚日志更早的read-view的时候。

### 相关操作
#### 查看隔离级别
1. `SHOW VARIABLES LIKE 'transaction_isolation';`
2. `SELECT @@transaction_isolation;`
#### 设置隔离级别
##### SET 命令
`SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;`
```
其中level有4种值：
level: {
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
}
```
1.　GLOBAL
- 只对执行完该语句之后产生的会话起作用  
- 当前已经存在的会话无效

2.　SESSION
- 只对当前会话中下一个即将开启的事务有效  
- 下一个事务执行完后，后续事务将恢复到之前的隔离级别  
- 该语句不能在已经开启的事务中间执行，会报错的 

##### 服务启动项命令
可以修改启动参数transaction-isolation的值

比方说我们在启动服务器时指定了--transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。