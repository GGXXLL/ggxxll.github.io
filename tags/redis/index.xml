<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Redis on Trock</title><link>https://ggxxll.github.io/tags/redis/</link><description>Recent content in Redis on Trock</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 11 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ggxxll.github.io/tags/redis/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis Zset</title><link>https://ggxxll.github.io/p/redis-zset/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://ggxxll.github.io/p/redis-zset/</guid><description>&lt;h2 id="编码选择">编码选择&lt;/h2>
&lt;p>有序集合对象的编码可以是 ziplist 或者 skiplist。&lt;/p>
&lt;p>使用 ziplist：&lt;/p>
&lt;ul>
&lt;li>元素数量小于128个&lt;/li>
&lt;li>所有member的长度都小于64字节&lt;/li>
&lt;/ul>
&lt;p>使用 skiplist：&lt;/p>
&lt;ul>
&lt;li>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件 &lt;code>zset-max-ziplist-entries&lt;/code> 选项和 &lt;code>zset-max-ziplist-value&lt;/code> 进行修改&lt;/li>
&lt;li>对于一个 &lt;code>REDIS_ENCODING_ZIPLIST&lt;/code> 编码的 Zset，只要满足以上任一条件，则会被转换为 &lt;code>REDIS_ENCODING_SKIPLIST&lt;/code> 编码&lt;/li>
&lt;/ul>
&lt;h2 id="ziplist">ziplist&lt;/h2>
&lt;h3 id="介绍">介绍&lt;/h3>
&lt;p>ziplist 编码的 Zset 使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。ziplist 内的集合元素按 score 从小到大排序，其实质是一个双向链表。虽然元素是按 score 有序排序的， 但对 ziplist 的节点指针只能线性地移动，所以在 &lt;code>REDIS_ENCODING_ZIPLIST&lt;/code> 编码的 Zset 中， 查找某个给定元素的复杂度为 O(N)。&lt;/p>
&lt;h3 id="结构">结构&lt;/h3>
&lt;p>各个部分在内存上是前后相邻的并连续的，每一部分作用如下：&lt;/p>
&lt;ul>
&lt;li>zlbytes： 存储一个无符号整数，固定四个字节长度（32bit），用于存储压缩列表所占用的字节（也包括 zlbytes 本身占用的4个字节），当重新分配内存的时候使用，不需要遍历整个列表来计算内存大小。&lt;/li>
&lt;li>zltail： 存储一个无符号整数，固定四个字节长度（32bit），表示 ziplist 表中最后一项（entry）在 ziplist 中的偏移字节数。 zltail 的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行 push 或 pop 操作。&lt;/li>
&lt;li>zllen： 压缩列表包含的节点个数，固定两个字节长度（16bit）， 表示ziplist中数据项（entry）的个数。由于zllen字段只有16bit，所以可以表达的最大值为2^16-1。&lt;/li>
&lt;/ul>
&lt;p>注意点：如果ziplist中数据项个数超过了16bit能表达的最大值，ziplist仍然可以表示。ziplist是如何做到的？&lt;/p>
&lt;p>如果 zllen 小于等于2^16-2（也就是不等于2^16-1），那么 zllen 就表示ziplist中数据项的个数；否则，也就是 zllen 等于16bit全为1的情况，那么 zllen 就不表示数据项个数了，这时候要想知道ziplist中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。&lt;/p>
&lt;p>entry，表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。&lt;/p>
&lt;p>zlend， ziplist最后1个字节，值固定等于255，其是一个结束标记。&lt;/p>
&lt;h2 id="skiplist">skiplist&lt;/h2>
&lt;h3 id="介绍-1">介绍&lt;/h3>
&lt;p>skiplist 编码的 Zset 底层为一个被称为 zset 的结构体，这个结构体中包含一个字典和一个跳跃表。跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 O(logN)，最坏 O(N) 。字典则保存着从 member 到 score 的映射，这样就可以用 O(1) 的复杂度来查找 member 对应的 score 值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的 member 和 score，因此不会浪费额外的内存。&lt;/p>
&lt;h3 id="详解">详解&lt;/h3>
&lt;p>跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。&lt;/p>
&lt;h2 id="qa">Q&amp;amp;A&lt;/h2>
&lt;ol>
&lt;li>Redis为什么用skiplist而不用平衡树？&lt;/li>
&lt;/ol>
&lt;p>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因。&lt;/p>
&lt;ul>
&lt;li>也不是非常耗费内存，实际上取决于生成层数函数里的概率 p，取决得当的话其实和平衡树差不多。&lt;/li>
&lt;li>因为有序集合经常会进行 ZRANGE 或 ZREVRANGE 这样的范围查找操作，跳表里面的双向链表可以十分方便地进行这类操作。&lt;/li>
&lt;li>实现简单，ZRANK 操作还能达到 o(logn) 的时间复杂度。&lt;/li>
&lt;/ul></description></item><item><title>Redis 持久化</title><link>https://ggxxll.github.io/p/redis-%E6%8C%81%E4%B9%85%E5%8C%96/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://ggxxll.github.io/p/redis-%E6%8C%81%E4%B9%85%E5%8C%96/</guid><description>&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Redis 运行时是将数据保存在内存中的，如果服务器宕机或者重启，内存中的数据必然会丢失。所以，必须要把数据持久化到磁盘，以便服务器故障时进行数据恢复。&lt;/p>
&lt;p>Redis持久化提供了两种方式，RDB（RedisDB）和 AOF（Appendonly File）。&lt;/p>
&lt;h2 id="rdb">RDB&lt;/h2>
&lt;p>RDB 就是在特定的条件下，将 Redis 的内存数据快照以二进制的方式保存到磁盘，文件名称 &lt;code>dump.rdb&lt;/code> 。&lt;/p>
&lt;p>调用 fork 方式创建子进程进行数据的持久化，所以会保留了持久化开始时刻的数据状况。&lt;/p>
&lt;p>关于 RDB，Redis提供了2种方式：&lt;/p>
&lt;ul>
&lt;li>命令：可以通过 &lt;code>save&lt;/code> （阻塞）和 &lt;code>bgsave&lt;/code> 命令，触发持久化写文件操作。&lt;/li>
&lt;li>配置文件：
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># save &amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">save 900 1 # 900 秒有 1 个 key 在被修改时持久化
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">save 300 10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">save 60 10000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rdbcompression yes # 默认开启数据压缩
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>优点：&lt;/p>
&lt;ol>
&lt;li>适合大规模的数据恢复。&lt;/li>
&lt;li>如果业务对数据完整性和一致性要求不高，RDB是很好的选择。&lt;/li>
&lt;/ol>
&lt;p>缺点：&lt;/p>
&lt;ol>
&lt;li>数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。&lt;/li>
&lt;li>备份时占用内存，因为 Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。&lt;/li>
&lt;/ol>
&lt;h2 id="aof">AOF&lt;/h2>
&lt;p>AOF Redis 默认不开启。它的出现是为了弥补 RDB 的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。。&lt;/p>
&lt;p>为了降低IO消耗，AOF写文件时，会先将数据写到缓冲区，然后再把缓冲区的内容 flush 到磁盘，这个过程叫做 fsync。&lt;/p>
&lt;p>AOF 的 flush 频率控制：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">appendfsync always //每次写操作都flush，影响性能
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">appendfsync everysec //每秒flush
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">appendfsync no //消极等待OS刷新(一般30s),可能丢失数据
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="aof-重写">AOF 重写&lt;/h3>
&lt;p>前面也说到了，AOF的工作原理是将写操作追加到文件中，文件的冗余内容会越来越多。所以聪明的 Redis 新增了重写机制。当 AOF 文件的大小超过所设定的阈值时，Redis 就会对 AOF 文件的内容压缩。&lt;/p>
&lt;p>重写的原理：Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的aof文件。&lt;/p>
&lt;p>触发机制：当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时触发。这里的“一倍”和“64M”可以通过配置文件修改。&lt;/p>
&lt;p>触发机制的配置参数：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">auto-aof-rewrite-percentage 100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">auto-aof-rewrite-min-size 64mb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>优点：数据的完整性和一致性更高&lt;/p>
&lt;p>缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。&lt;/p></description></item></channel></rss>