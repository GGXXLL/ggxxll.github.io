<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mysql on Trock</title><link>https://ggxxll.github.io/tags/mysql/</link><description>Recent content in Mysql on Trock</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 10 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ggxxll.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>Mysql MVCC</title><link>https://ggxxll.github.io/p/mysql-mvcc/</link><pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate><guid>https://ggxxll.github.io/p/mysql-mvcc/</guid><description>&lt;h3 id="mvcc">MVCC&lt;/h3>
&lt;p>全称 Multi-Version Concurrency Control, 即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。&lt;/p>
&lt;p>MVCC 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读&lt;/p>
&lt;h3 id="当前读和快照读">当前读和快照读&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>当前读
像 select lock in share mode (共享锁), select for update; update; insert; delete (排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>快照读
像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="log">Log&lt;/h3>
&lt;h4 id="binlog">BinLog&lt;/h4>
&lt;p>binlog：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的, 另外通过解析binlog能够实现mysql到其他数据源（如 ElasticSearch )的数据复制。&lt;/p>
&lt;h4 id="redolog">RedoLog&lt;/h4>
&lt;p>redo log：记录了数据操作在物理层面的修改，mysql中使用了大量缓存，缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘，当内存和磁盘的数据不一致时，称内存中的数据为脏页(dirty page)。为了保证数据的安全性，事务进行中时会不断的产生 redo log，在事务提交时进行一次 flush 操作，保存到磁盘中, redo log 是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据库或主机失效重启时，会根据 redo log 进行数据的恢复，如果 redo log 中有事务提交，则进行事务提交修改数据。这样实现了事务的原子性、一致性和持久性。&lt;/p>
&lt;h4 id="undolog">UndoLog&lt;/h4>
&lt;p>undo log：除了记录 redo log 外，当进行数据修改时还会记录 undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过 undo log 可以实现事务回滚，并且可以根据 undo log 回溯到某个特定的版本的数据，实现 MVCC。&lt;/p>
&lt;h3 id="readview">ReadView&lt;/h3>
&lt;p>MVCC 只在 read-committed（RC） 和 repeatable-read（RR） 两个隔离级别下工作，而 read-committed 和 repeatable-read 的区别就在于它们生成 ReadView 的时机不同。&lt;/p>
&lt;p>对于使用 read-committed 和 repeatable-read 隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。&lt;/p>
&lt;p>核心问题就是：需要判断一下，版本链中的哪个版本是当前事务可见的。&lt;/p>
&lt;p>为此，InnoDB 提出了一个 ReadView 的概念，这个 ReadView 中有个 id 列表 trx_ids 来存储系统中当前活跃着的读写事务，也就是 begin 了还未 commit 或 rollback 的事务。其中最主要的与可见性相关的属性如下：&lt;/p>
&lt;ul>
&lt;li>up_limit_id：当前已经提交的事务号 + 1，事务号 &amp;lt; up_limit_id ，对于当前 Read View 都是可见的。理解起来就是创建 Read View 视图的时候，之前已经提交的事务对于该事务肯定是可见的。&lt;/li>
&lt;li>low_limit_id：当前最大的事务号 + 1，事务号 &amp;gt;= low_limit_id，对于当前 Read View 都是不可见的。理解起来就是在创建 Read View 视图之后创建的事务对于该事务肯定是不可见的。&lt;/li>
&lt;li>trx_ids：为活跃事务 id 列表，即 Read View 初始化时当前未提交的事务列表。所以当进行 RR 读的时候，trx_ids 中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）。理解起来就是创建 Read View 时，将当前活跃事务 ID 记录下来，后续即使他们提交对于本事务也是不可见的。&lt;/li>
&lt;li>creator_trx_id：当前事务自身的 id&lt;/li>
&lt;/ul>
&lt;p>可重复读隔离级别下，ReadView 只会在第一次查询时创建，同一个事务中后续所有的查询共用一个 ReadView，由此便解决了不可重复读的问题。&lt;/p>
&lt;p>读已提交隔离级别下，每次查询都会创建一个新的 ReadView。新建的 ReadView 会更新 creator_trx_id 以外的其余字段，因此不可重复读现象依然存在。但是由于ReadView可以判断出修改此数据的事务是否已经提交，因此可以避免脏读的出现。&lt;/p>
&lt;p>其次，从上述MVCC实现逻辑中可以发现，没有任何加锁、获取锁的操作，因此MVCC读操作不会因为等待锁而阻塞（也就是常说的非阻塞读）。&lt;/p>
&lt;h3 id="mvcc-原理">MVCC 原理&lt;/h3>
&lt;p>MySQL的每行记录逻辑上其实是一个链表。&lt;/p>
&lt;p>MySQL行记录中除了记录业务数据外，还有隐藏的 trx_id 和 roll_pointer&lt;/p>
&lt;ul>
&lt;li>trx_id：表示最近修改的事务的id ，每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务 id 赋值给 trx_id 隐藏列。新增一个事务时，trx_id 会递增，因此 trx_id 能够表示事务开始的先后顺序。&lt;/li>
&lt;li>roll_pointer：指向该行上一个版本的地址，每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 UndoLog 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。&lt;/li>
&lt;/ul>
&lt;h3 id="mvcc-能解决什么问题好处是">MVCC 能解决什么问题，好处是？&lt;/h3>
&lt;p>数据库并发场景有三种，分别为：&lt;/p>
&lt;ul>
&lt;li>读-读：不存在任何问题，也不需要并发控制&lt;/li>
&lt;li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读&lt;/li>
&lt;li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失&lt;/li>
&lt;/ul></description></item><item><title>Mysql 索引</title><link>https://ggxxll.github.io/p/mysql-%E7%B4%A2%E5%BC%95/</link><pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate><guid>https://ggxxll.github.io/p/mysql-%E7%B4%A2%E5%BC%95/</guid><description>&lt;h3 id="介绍">介绍&lt;/h3>
&lt;p>索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引用于快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。&lt;/p>
&lt;p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。&lt;/p>
&lt;p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)，而不是在 SELECT 的字段中，实际上，索引也是一张“表”，该表保存了主键与索引字段，并指向实体表的记录，虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE和DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件，建立索引会占用磁盘空间的索引文件。说白了索引就是用来提高速度的，但是就需要维护索引造成资源的浪费，所以合理的创建索引是必要的。&lt;/p>
&lt;h4 id="分类">分类&lt;/h4>
&lt;p>先去官网文档看看支持的索引类型，索引的实现方式如下图所示：&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html" target="_blank" rel="noopener"
>官网&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://ggxxll.github.io/img/%e7%b4%a2%e5%bc%95-%e7%b1%bb%e5%88%ab.webp"
loading="lazy"
>&lt;/p>
&lt;p>由于本文是基于 MySQL 的 InnoDB 存储引擎，索引我们主要看第一个表格，其他的表格可以自行的观看，都不难，从表格我们可以看出来，InnoDB存储引擎索引只支持BTREE类型的索引，索引的类别有Primary Key，Unique，Key，FULLTEXT和SPATIAL。当然也有其他的分法，按照索引列的数量分为单列索引和组合索引。&lt;/p>
&lt;ol>
&lt;li>Primary Key（聚集索引）：InnoDB 存储引擎的表会存在主键（唯一非 null），如果建表的时候没有指定主键，则会使用第一非空的唯一索引作为聚集索引，否则 InnoDB 会自动帮你创建一个不可见的、长度为 6 字节的 row_id 用来作为聚集索引。&lt;/li>
&lt;li>单列索引：单列索引即一个索引只包含单个列&lt;/li>
&lt;li>组合索引：组合索引指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循&lt;strong>最左前缀集合&lt;/strong>&lt;/li>
&lt;li>Unique（唯一索引）：索引列的值必须唯一，但允许有空值。若是组合索引，则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值&lt;/li>
&lt;li>Key（普通索引）：是 MySQL 中的基本索引类型，允许在定义索引的列中插入重复值和空值&lt;/li>
&lt;li>FULLTEXT（全文索引）：全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在 CHAR、VARCHAR 或者 TEXT 类型的列上创建&lt;/li>
&lt;li>SPATIAL（空间索引）：空间索引是对空间数据类型的字段建立的索引，MySQL 中的空间数据类型有4种，分别是 GEOMETRY、POINT、LINESTRING和POLYGON。MySQL 使用 SPATIAL 关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列必须声明为 NOT NULL&lt;/li>
&lt;/ol>
&lt;h4 id="创建原则">创建原则&lt;/h4>
&lt;ol>
&lt;li>&lt;strong>索引并非越多越好&lt;/strong>，一个表中如果有大量的索引，不仅占用磁盘空间，而且会影响 INSERT、DELETE、UPDATE 等语句的性能，因为在表中的数据更改的同时，索引也会进行调整和更新&lt;/li>
&lt;li>&lt;strong>避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引&lt;/strong>，但要避免添加不必要的字段。&lt;/li>
&lt;li>&lt;strong>数据量小的表最好不要使用索引&lt;/strong>，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。&lt;/li>
&lt;li>&lt;strong>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引&lt;/strong>。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。&lt;/li>
&lt;li>&lt;strong>当唯一性是某种数据本身的特征时，指定唯一索引&lt;/strong>。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。&lt;/li>
&lt;li>&lt;strong>在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引&lt;/strong>，如果待排序的列有多个，可以在这些列上建立组合索引。&lt;/li>
&lt;li>&lt;strong>搜索的索引列，不一定是所要选择的列&lt;/strong>。换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。&lt;/li>
&lt;li>&lt;strong>使用短索引&lt;/strong>。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个 CHAR(200) 列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL 也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性。&lt;/li>
&lt;li>&lt;strong>利用最左前缀&lt;/strong>。在创建一个 n 列的索引时，实际是创建了 MySQL 可利用的 n 个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。&lt;/li>
&lt;li>对于 InnoDB 存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以InnoDB表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以&lt;strong>主键要尽可能选择较短的数据类型&lt;/strong>，可以有效地减少索引的磁盘占用，提高索引的使用效果&lt;/li>
&lt;/ol>
&lt;h3 id="索引的管理和使用">索引的管理和使用&lt;/h3>
&lt;h4 id="explain">EXPLAIN&lt;/h4>
&lt;p>基本语法：&lt;code>EXPLAIN SELECT ...&lt;/code>&lt;/p>
&lt;p>结果：&lt;/p>
&lt;ul>
&lt;li>id：SELECT 识别符。这是 SELECT 的查询序列号,表示查询中执行 SELECT 子句或操作表的顺序, id 相同，执行顺序从上到下,id 不同，id 值越大执行优先级越高&lt;/li>
&lt;li>select_type：表示 SELECT 语句的类型。它可以是以下几种取值：
&lt;ul>
&lt;li>SIMPLE：表示简单查询，其中不包括连接查询和子查询；&lt;/li>
&lt;li>PRIMARY：表示主查询，或者是最外层的查询语句，最外层查询为 PRIMARY ，也就是最后加载的就是- PRIMARY；&lt;/li>
&lt;li>UNION：表示连接查询的第2个或后面的查询语句， 不依赖于外部查询的结果集&lt;/li>
&lt;li>DEPENDENT UNION：连接查询中的第2个或后面的 SELECT 语句，依赖于外面的查询；&lt;/li>
&lt;li>UNION RESULT：连接查询的结果；&lt;/li>
&lt;li>SUBQUERY：子查询中的第1个 SELECT 语句；不依赖于外部查询的结果集&lt;/li>
&lt;li>DEPENDENT SUBQUERY：子查询中的第1个 SELECT，依赖于外面的查询；&lt;/li>
&lt;li>DERIVED：导出表的 SELECT（FROM 子句的子查询）,MySQL 会递归执行这些子查询，把结果放在临时表里。&lt;/li>
&lt;li>DEPENDENT DERIVED：派生表依赖于另一个表&lt;/li>
&lt;li>MATERIALIZED：物化子查询&lt;/li>
&lt;li>UNCACHEABLE SUBQUERY：子查询，其结果无法缓存，必须针对外部查询的每一行重新进行评估&lt;/li>
&lt;li>UNCACHEABLE UNION：UNION中的第二个或随后的 SELECT 查询，属于不可缓存的子查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>table：表示查询的表&lt;/li>
&lt;li>partitions：查询将从中匹配记录的分区。该值适用NULL于未分区的表&lt;/li>
&lt;li>type：表示表的连接类型
&lt;ul>
&lt;li>system：该表是仅有一行的系统表。这是 const 连接类型的一个特例&lt;/li>
&lt;li>const： 数据表最多只有一个匹配行，它将在查询开始时被读取，并在余下的查询优化中作为常量对待。const 表查询速度很快，因为只读取一次,const 用于使用常数值比较 PRIMARY KEY 或 UNIQUE 索引的所有部分的场合。&lt;/li>
&lt;li>eq_ref：对于每个来自前面的表的行组合，从该表中读取一行,可以用于使用“＝”运算符进行比较的索引列 。比较值可以是常量，也可以是使用在此表之前读取的表中列的表达式
ref：对于来自前面的表的任意行组合，将从该表中读取所有匹配的行，ref可以用于使用“＝”或“＜＝＞”操作符的带索引的列。&lt;/li>
&lt;li>fulltext：使用 FULLTEXT 索引执行联接&lt;/li>
&lt;li>ref_or_null：这种连接类型类似于 ref，但是除了 MySQL 还会额外搜索包含 NULL 值的行。此联接类型优化最常用于解析子查询&lt;/li>
&lt;li>index_merge：此联接类型指示使用索引合并优化。在这种情况下，key 输出行中的列包含使用的索引列表，并且 key_len 包含使用的索引的最长键部分的列表&lt;/li>
&lt;li>unique_subquery：类型替换 以下形式的eq_ref某些 IN子查询, unique_subquery 只是一个索引查找函数，它完全替代了子查询以提高效率。&lt;/li>
&lt;li>index_subquery：连接类型类似于 unique_subquery。它代替 IN 子查询,但只适合子查询中的非唯一索引&lt;/li>
&lt;li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len 包含所使用索引的最长关键元素。当使用 ＝、＜＞、＞、＞＝、＜、＜＝、IS NULL、＜＝＞、BETWEEN 或者 IN 操作符用常量比较关键字列时，类型为range
index：该 index 联接类型是一样的 ALL，只是索引树被扫描。这发生两种方式：
&lt;ol>
&lt;li>如果索引是查询的覆盖索引，并且可用于满足表中所需的所有数据，则仅扫描索引树。在这种情况下，Extra列显示为 - Using index;&lt;/li>
&lt;li>使用对索引的读取执行全表扫描，以按索引顺序查找数据行。 Uses index 没有出现在 Extra列中;&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ALL：对于前面的表的任意行组合进行完整的表扫描&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>possible_keys：指出MySQL能使用哪个索引在该表中找到行。若该列是 NULL，则没有相关的索引。在这种情况下，可以通过检查 WHERE 子句看它是否引用某些列或适合索引的列来提高查询性能。如果是这样，可以创建适合的索引来提高查询的性能。&lt;/li>
&lt;li>kye：表示查询实际使用的索引，如果没有选择索引，该列的值是 NULL。要想强制 MySQL 使用或忽视 possible_keys 列中的索引，在查询中使用 FORCE INDEX、USE INDEX 或者 IGNORE INDEX&lt;/li>
&lt;li>key_len：表示 MySQL 选择的索引字段按字节计算的长度，若键是 NULL，则长度为 NULL。注意，通过 key_len 值可以确定 MySQL 将实际使用一个多列索引中的几个字段&lt;/li>
&lt;li>ref：表示使用哪个列或常数与索引一起来查询记录。&lt;/li>
&lt;li>rows：显示 MySQL 在表中进行查询时必须检查的行数。&lt;/li>
&lt;li>Extra：表示 MySQL 在处理查询时的详细信息&lt;/li>
&lt;/ul>
&lt;p>更详细说明见官网：https://dev.mysql.com/doc/refman/8.0/en/explain-output.html&lt;/p>
&lt;h4 id="操作索引">操作索引&lt;/h4>
&lt;p>创建索引的语法（如下都是默认的innodb存储引擎）：https://dev.mysql.com/doc/refman/8.0/en/create-index.html&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [index_type]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ON tbl_name (key_part,...)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [index_option]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [algorithm_option | lock_option] ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">key_part: {col_name [(length)] | (expr)} [ASC | DESC]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">index_option: {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> KEY_BLOCK_SIZE [=] value
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | index_type
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | WITH PARSER parser_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | COMMENT &amp;#39;string&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | {VISIBLE | INVISIBLE}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | ENGINE_ATTRIBUTE [=] &amp;#39;string&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | SECONDARY_ENGINE_ATTRIBUTE [=] &amp;#39;string&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">index_type:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> USING {BTREE | HASH}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">algorithm_option:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ALGORITHM [=] {DEFAULT | INPLACE | COPY}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lock_option:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length],...) [ASC|DESC]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ALTER TABLE table_name DROP INDEX index_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DROP INDEX index_name ON table_name;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="聚集索引和二级索引">聚集索引和二级索引&lt;/h3>
&lt;h4 id="聚集索引">聚集索引&lt;/h4>
&lt;p>InnoDB 存储引擎表是索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵 B+ 树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同 B+ 树数据结构一样，每个数据页都通过一个双向链表来进行链接。&lt;/p>
&lt;p>由于实际的数据页只能按照一棵 B+ 树进行排序，因此每张表只能拥有一个聚集索引。由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。查询优化器能够快速发现某一段范围的数据页需要扫描。&lt;/p>
&lt;p>聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：一是前面说过的页通过双向链表链接，页按照主键的顺序排序；另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。&lt;/p>
&lt;h4 id="二级索引">二级索引&lt;/h4>
&lt;p>对于辅助索引（Secondary Index），叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）。该书签用来告诉 InnoDB 存储引擎哪里可以找到与索引相对应的行数据。由于 InnoDB 存储引擎表是索引组织表，因此 InnoDB 存储引擎的辅助索引的书签就是相应行数据的聚集索引键。&lt;/p>
&lt;p>当通过辅助索引来寻找数据时，InnoDB 存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。&lt;/p>
&lt;h3 id="覆盖索引">覆盖索引&lt;/h3>
&lt;p>InnoDB 存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的 IO 操作。&lt;/p>
&lt;h3 id="multi-range-read-优化">Multi-Range Read 优化&lt;/h3>
&lt;p>Multi-Range Read 优化的目的就是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这对于 IO-bound 类型的 SQL 查询语句可带来性能极大的提升。Multi-RangeRead 优化可适用于 range、ref、eq_ref 类型的查询。&lt;/p>
&lt;p>Multi-Range Read 的好处：&lt;/p>
&lt;ul>
&lt;li>MRR 使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。&lt;/li>
&lt;li>减少缓冲池中页被替换的次数。&lt;/li>
&lt;li>批量处理对键值的查询操作&lt;/li>
&lt;/ul>
&lt;p>MRR 的工作方式如下：&lt;/p>
&lt;ul>
&lt;li>将查询得到的辅助索引键值存放于一个缓存中，这时缓存中的数据是根据辅助索引键值排序的。&lt;/li>
&lt;li>将缓存中的键值根据 RowID 进行排序。&lt;/li>
&lt;li>根据 RowID 的排序顺序来访问实际的数据文件。&lt;/li>
&lt;/ul>
&lt;p>MySQL5.6版本开始支持 Multi-Range Read（MRR）优化，通过参数 optimizer_switch 的标记来控制是否使用 MRR，当设置mrr=on 时，表示启用MRR优化。mrr_cost_based 表示是否通过 cost base 的方式来启用 MRR。如果选择 mrr=on,mrr_cost_based=off,则表示总是开启 MRR 优化。&lt;/p>
&lt;h3 id="index-condition-pushdownicp优化">Index Condition Pushdown（ICP）优化&lt;/h3>
&lt;p>MySQL 数据库会在取出索引的同时，判断是否可以进行 WHERE 条件的过滤，也就是将 WHERE 的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层 SQL 层对记录的索取（fetch），从而提高数据库的整体性能，优化支持 range、ref、eq_ref、ref_or_null 类型的查询，选择 Index Condition Pushdown 优化时，可在执行计划的列 Extra 看到 Using index condition 提示。&lt;/p>
&lt;ol>
&lt;li>当 SQL 需要全表访问时，ICP 的优化策略可用于 range, ref, eq_ref, ref_or_null 类型的访问数据方法。&lt;/li>
&lt;li>支持 InnoDB 和 MyISAM 表。&lt;/li>
&lt;li>ICP 只能用于二级索引，不能用于主索引。&lt;/li>
&lt;li>并非全部 WHERE 条件都可以用ICP筛选，如果 WHERE 条件的字段不在索引列中，还是要读取整表的记录到 server 端做条件过滤。&lt;/li>
&lt;/ol>
&lt;h3 id="索引实现的原理">索引实现的原理&lt;/h3>
&lt;p>InnoDB 存储的索引是基于 B+ 树实现的，不支持hash的实现方式。首先来了解下 B+ 树的特点；&lt;/p>
&lt;h4 id="b树的特征">B+树的特征&lt;/h4>
&lt;p>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。&lt;/p>
&lt;h4 id="b树的优势">B+树的优势&lt;/h4>
&lt;ul>
&lt;li>单一节点存储更多的元素，使得查询的IO次数更少。&lt;/li>
&lt;li>所有查询都要查找到叶子节点，查询性能稳定。&lt;/li>
&lt;li>所有叶子节点形成有序链表，便于范围查询。&lt;/li>
&lt;/ul>
&lt;p>在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。先来看一个B+树，其高度为
2，每页可存放4条记录，扇出（fan out）为5，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://ggxxll.github.io/img/%e7%b4%a2%e5%bc%951.webp"
loading="lazy"
>&lt;/p>
&lt;h4 id="索引的设计思考">索引的设计思考&lt;/h4>
&lt;ul>
&lt;li>索引是一种存储方式，最相关的硬件就是磁盘，索引磁盘的性能会直接影响到数据库的查询效率&lt;/li>
&lt;li>磁盘的性能和读写的顺序有关，普通磁盘顺序读写比随机读写快很多，所以尽量避免随机读写。&lt;/li>
&lt;li>数据都是以行为单位一行一行的存储的，每一行都包括了所有的列，多行可以连续存储。&lt;/li>
&lt;li>每一行数据中，一般都有一个键，其他的列可以称为值，可以理解为键值对。innodb必须有唯一非空的主键，就是默认的键。&lt;/li>
&lt;li>在键值对中，键值可以排序，还可以组合键值。&lt;/li>
&lt;/ul>
&lt;h4 id="索引的设计">索引的设计&lt;/h4>
&lt;ul>
&lt;li>磁盘空间会划分为许多个大小相等的块或者页，一个页中可以存储多行数据，这样就可以符合磁盘的顺序读写，这样一次IO就可以读取很多数据到内存，可以减少磁盘IO。&lt;/li>
&lt;li>在一个页内，所有的数据可能会经常变动，并且大小也是相对固定的，所以内部通过链表或者数组管理。&lt;/li>
&lt;li>每个键值可以排序，所以在一个块内的所有数据也可以是有序的，这样通过二分法查找可以很快的在一个页内找到指定键对应的数据&lt;/li>
&lt;li>一个页设计好之后，可以把页作为B+树的节点，通过页来承载数据，通过B+数来组织不同页之间的关系&lt;/li>
&lt;li>B+树的特点是在内节点存储键来提高搜索的性能，所以很自然的，内节点用来存储数据行的键，叶子节点存储所有数据行，可以很好的提升性能&lt;/li>
&lt;/ul>
&lt;p>接下来结合&lt;a class="link" href="#%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e5%92%8c%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95" >2.5节的聚集索引和二级索引&lt;/a>来说：&lt;/p>
&lt;p>表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://ggxxll.github.io/img/%e7%b4%a2%e5%bc%952.webp"
loading="lazy"
>&lt;/p>
&lt;p>　　上图所示的是一个深度为2的B+树，也是我们所称的索引，这里假设页有随机唯一的编号，根页号为20。这里只有一个内节点（根节点），其他的都是叶子节点，也是数据节点，对于内节点来说，存有key和pageno的指针信息，对于叶子节点来说，只存有完整的数据。对于聚集索引，data部分存有除主键外的其他列的组合，如果是二级索引，则这里存放就是这行记录对应主键的组合，用于回表。&lt;/p>
&lt;p>　　最左边的MIN为了很好的组织树形结构的指针，和其他的内节点一样，主要用来标记它是最小记录Min，还有就是一个pageno指针指向下层最左边的Min记录，其他节点的Min记录用于判断搜索是否到了边界。每个页都有页头页尾用来管理和标记页面的状态，页面中的数据是如何存储，有没有空闲的空间，以什么样的顺序存储等。&lt;/p>
&lt;p>　　上图中所有的叶子节点从左到右都是从小到大的顺序以双向链表的方式存储的，所以当我们需要遍历全部的数据，只需要通过B+树找到最小的位置，然后通过遍历链表则可以查询到所有的数据，还有就是10,16,25这三条记录在内节点和叶子节点均存在，这既是B+数的特点，叶子节点会存有所有的key和值。而内节点只存储了key，不存储其他的数据，只有用来索引。叶子节点除了第一条记录会有上一层重复的存储，其他数据不会有这样的现象，所以浪费的空间也不大，由于每一个页的大小是固定的（16k），在内节点上只存储key，不存储其他数据，一个页就可以存储更多的key，这样检索也能减少磁盘的IO，由于页存储Key增多，这样就可以使得B+树的深度减少，这样也可以减少磁盘的IO，提高查询性能。&lt;/p>
&lt;p>例如一个三层的B+数，每一个页能存1000个key，所以第二层就有1000*（1+1000）个key，第三层就可以有1000&lt;em>1001&lt;/em>1001=1002001000（十亿级别），一个简单的三层B+数据就可以存十亿级别的数据，很强大。&lt;/p>
&lt;p>　　上面说到的“回表”其实就是在使用二级索引进行搜索时，因为二级索引只保存了部分列的数据，如果需要获取键值不包括的列的数据时，需要通过二级索引的指针（书签：用于指向聚集索引的指针）来找到聚集索引的全部数据，然后返回需要查询的列的值。如果使用二级索引不能找到需要的值（需要回表），称为非覆盖索引，否则为2.6节介绍的覆盖索引。非覆盖索引需要回表，增加IO，所以性能会差一些。所以可以根据业务需求创建组合索引来避免回表。但是也要权衡索引带来的利是否大于弊。所以在统计行总数的时候可以通过二级索引来统计，这样速度会快一些。大概图形如下：&lt;/p>
&lt;p>&lt;img src="https://ggxxll.github.io/img/%e7%b4%a2%e5%bc%953.webp"
loading="lazy"
>&lt;/p>
&lt;p>　　这里附带的说一些不能走索引的情况，但是不多说，因为优化这个东西太多，后期准备写一两篇优化的文章，所以这里只是提一下，走索引的强大；虽然可能创建了很多索引，很多情况都不走索引，比如：like &amp;lsquo;%query_name%&amp;rsquo; ，where端使用or条件连接，where端使用函数等，在group by和order by使用的时候要注意组合索引的最左前缀原则。&lt;/p>
&lt;h3 id="引用">引用&lt;/h3>
&lt;p>copy from &lt;a class="link" href="https://www.cnblogs.com/zsql/p/13808417.html#_label2" target="_blank" rel="noopener"
>https://www.cnblogs.com/zsql/p/13808417.html#_label2&lt;/a>&lt;/p></description></item><item><title>Mysql 锁（二）</title><link>https://ggxxll.github.io/p/mysql-%E9%94%81%E4%BA%8C/</link><pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate><guid>https://ggxxll.github.io/p/mysql-%E9%94%81%E4%BA%8C/</guid><description>&lt;p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类&lt;/p>
&lt;h3 id="全局锁">全局锁&lt;/h3>
&lt;p>全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 &lt;code>Flush tables with read lock&lt;/code> 。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句&lt;/p>
&lt;p>全局锁的典型使用场景是，做全库逻辑备份。&lt;/p>
&lt;p>但是整个库都只读，可能出现以下问题：&lt;/p>
&lt;ul>
&lt;li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆&lt;/li>
&lt;li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟&lt;/li>
&lt;/ul>
&lt;p>在可重复读隔离级别下开启一个事务能够拿到一致性视图&lt;/p>
&lt;p>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 &lt;code>–single-transaction&lt;/code> 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。&lt;code>single-transaction&lt;/code> 只适用于所有的表使用事务引擎的库&lt;/p>
&lt;p>1.既然要全库只读，为什么不使用&lt;code>set global readonly=true&lt;/code>的方式？&lt;/p>
&lt;ul>
&lt;li>在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此修改 global 变量的方式影响面更大&lt;/li>
&lt;li>在异常处理机制上有差异。如果执行&lt;code>Flush tables with read lock&lt;/code>命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高&lt;/li>
&lt;/ul>
&lt;h3 id="表级锁">表级锁&lt;/h3>
&lt;p>&lt;strong>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL）&lt;/strong>&lt;/p>
&lt;h4 id="表锁">表锁&lt;/h4>
&lt;p>表锁的语法是 &lt;code>lock tables … read/write&lt;/code>。可以用 &lt;code>unlock tables&lt;/code> 主动释放锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象&lt;/p>
&lt;p>如果在某个线程 A 中执行 &lt;code>lock tables t1 read,t2 wirte&lt;/code>;这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 &lt;code>unlock tables&lt;/code> 之前，也只能执行读 t1、读写 t2 的操作，连写t1都不允许&lt;/p>
&lt;h4 id="元数据锁">元数据锁&lt;/h4>
&lt;p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做了变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定不行&lt;/p>
&lt;p>&lt;strong>在MySQL5.5版本引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>读锁之间不互斥，因此可以多个线程同时对一张表增删改查&lt;/li>
&lt;li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果安全地给小表加字段？&lt;br>
首先要解决长事务，事务不提交，就会一直占着 DML 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行的事务。如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而又不得不加个字段，该怎么做？&lt;br>
在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，之后再通过重试命令重复这个过程&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="行锁">行锁&lt;/h3>
&lt;p>MySQL的行锁是在引擎层由各个引擎自己实现的。但不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁&lt;/p>
&lt;p>行锁就是针对数据表中行记录的锁。比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更。事务 A 持有的两个记录的行锁都是在 commit 的时候才释放的，事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行&lt;/p>
&lt;h4 id="两阶段锁协议">两阶段锁协议&lt;/h4>
&lt;p>&lt;strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放&lt;/strong>。这个就是两阶段锁协议&lt;/p>
&lt;p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放&lt;/p>
&lt;h4 id="死锁和死锁检测">死锁和死锁检测&lt;/h4>
&lt;p>&lt;strong>在并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁&lt;/strong>&lt;/p>
&lt;p>当出现死锁以后，有两种策略：&lt;/p>
&lt;ul>
&lt;li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数&lt;code> innodb_lock_wait_timeout&lt;/code> 来设置&lt;/li>
&lt;li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数&lt;code>innodb_deadlock_detect&lt;/code> 设置为 on，表示开启这个逻辑&lt;/li>
&lt;/ul>
&lt;p>在 InnoDB 中，&lt;code>innodb_lock_wait_timeout&lt;/code>的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的&lt;/p>
&lt;p>正常情况下还是要采用主动死锁检查策略，而且 &lt;code>innodb_deadlock_detect&lt;/code> 的默认值本身就是on。主动死锁监测在发生死锁的时候，是能够快速发现并进行处理的，但是它有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁&lt;/p>
&lt;p>如果所有事务都要更新同一行的场景，每个新来的被堵住的线程都要判断会不会由于自己的加入导致死锁，这是一个时间复杂度是 O(n) 的操作&lt;/p>
&lt;p>怎么解决由这种热点行更新导致的性能问题？&lt;/p>
&lt;ol>
&lt;li>如果确保这个业务一定不会出现死锁，可以临时把死锁检测关掉&lt;/li>
&lt;li>控制并发度&lt;/li>
&lt;li>将一行改成逻辑上的多行来减少锁冲突。以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成员原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗&lt;/li>
&lt;/ol>
&lt;h3 id="引用">引用&lt;/h3>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/qq_40378034/article/details/90904573" target="_blank" rel="noopener"
>https://blog.csdn.net/qq_40378034/article/details/90904573&lt;/a>&lt;/p></description></item><item><title>Mysql 锁（一）</title><link>https://ggxxll.github.io/p/mysql-%E9%94%81%E4%B8%80/</link><pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate><guid>https://ggxxll.github.io/p/mysql-%E9%94%81%E4%B8%80/</guid><description>&lt;h3 id="概述">概述&lt;/h3>
&lt;p>锁机制用于管理对共享资源的并发访问。&lt;/p>
&lt;p>锁可大致分为两类：&lt;/p>
&lt;ul>
&lt;li>lock：对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务 commit 或者 rollback 后进行释放。有死锁检测机制。&lt;/li>
&lt;li>latch：闩锁（shuang suo），其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在 InnoDB 存储引擎中，latch 又分为
mutex 互斥锁 和 rwLock 读写锁。
其目的是为了保证并发线程操作临界资源的正确性。通常没有死锁的检测机制。&lt;/li>
&lt;/ul>
&lt;h3 id="锁的类型">锁的类型&lt;/h3>
&lt;h4 id="共享锁排他锁">共享锁，排他锁&lt;/h4>
&lt;p>InnoDB存储引擎实现了如下两种标准的行级锁：&lt;/p>
&lt;p>共享锁（S Lock）：允许事务读取一行数据。&lt;/p>
&lt;p>排他锁（X Lock）：允许事务删除或者更新一行数据。&lt;/p>
&lt;p>这里可以理解为读写锁，可并行读，但是不可以：并行写、并行读写。&lt;/p>
&lt;p>排它锁是很强的锁，不与其他类型的锁兼容。这也很好理解，修改和删除某一行的时候，必须获得强锁，禁止这一行上的其他并发，以保障数据的一致性。&lt;/p>
&lt;h4 id="记录锁">记录锁&lt;/h4>
&lt;p>Record Lock，&lt;strong>仅锁定一行记录&lt;/strong>（如共享锁、排他锁）&lt;/p>
&lt;p>记录锁总是会去锁定索引记录，如果表在建立的时候，没有设置任何索引，InnoDB 会使用隐式的主键进行锁定。
查询条件的列是唯一索引的情况下，临键锁退化为记录锁。&lt;/p>
&lt;h4 id="间隙锁">间隙锁&lt;/h4>
&lt;p>Gap Lock，&lt;strong>锁定一个范围，但不包括记录本身&lt;/strong>。
关闭间隙锁的两种方式：&lt;/p>
&lt;ol>
&lt;li>将事务隔离级别设置为 读已提交（read committed）&lt;/li>
&lt;li>将参数 innodb_locks_unsafe_for_binlog 设置为 1&lt;/li>
&lt;/ol>
&lt;p>在上述配置下，除了外键和唯一性检查依然需要间隙锁，其余情况均使用行锁进行锁定。&lt;/p>
&lt;h4 id="临键锁">临键锁&lt;/h4>
&lt;p>Next-Key Lock，等于记录锁+间隙锁，&lt;strong>锁定一个范围，并锁定记录本身&lt;/strong>.&lt;/p>
&lt;p>主要是阻止多个事务将记录插入到同一个范围内，从而避免幻读。&lt;/p>
&lt;p>当查询的索引是唯一索引时，InnoDB 会将临键锁优化为记录锁，从而提高并发。这时候，将不再使用间隙锁来避免幻读。&lt;/p>
&lt;h4 id="意向锁">意向锁&lt;/h4>
&lt;p>事务可能要加共享/排他锁，先提前声明一个意向。&lt;/p>
&lt;p>InnoDB 支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持不同粒度上进行加锁操作，InnoDB
存储引擎支持一种额外的锁方式，
称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更粗的粒度上进行加锁。&lt;/p>
&lt;p>特点：&lt;/p>
&lt;ol>
&lt;li>意向锁是表级别锁&lt;/li>
&lt;li>意向锁可分为：
&lt;ul>
&lt;li>意向共享锁（intention shared lock, IS）：表示事务有意向对表中的某些行加共享锁&lt;/li>
&lt;li>意向排它锁（intention exclusive lock, IX）：表示事务有意向对表中的某些行加排它锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>意向锁协议：
&lt;ul>
&lt;li>事务要获得某些行的共享锁，必须先获得表的意向共享锁 IS&lt;/li>
&lt;li>事务要获取某些行的排他锁，必须先获得表的意向排他锁 IX&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>由于意向锁仅表明意向，所以是比较弱的锁，意向锁之间不互斥，可以并行&lt;/li>
&lt;li>意向锁之间可以并行，但与共享锁和排它锁互斥，表现为 S+IS 可并行读，其他均互斥。&lt;/li>
&lt;/ol>
&lt;h4 id="插入意向锁">插入意向锁&lt;/h4>
&lt;p>对已有数据行的修改与删除，必须使用排他锁，那对于数据的插入，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。&lt;/p>
&lt;p>插入意向锁，是间隙锁（Gap Locks）的一种（所以，也是实施在索引上的），&lt;strong>它是专门针对 INSERT 操作的&lt;/strong>。&lt;/p>
&lt;p>它的用处是：&lt;strong>多个事务，在同一个索引上插入记录时，如果插入的位置不冲突，不会阻塞彼此&lt;/strong>。&lt;/p>
&lt;h4 id="自增锁">自增锁&lt;/h4>
&lt;p>自增锁是 MySQL一种特殊的锁，如果&lt;strong>表中存在自增字段，MySQL便会自动维护一个自增锁&lt;/strong>。&lt;/p>
&lt;p>在 InnoDB 存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长计数器的表进行插入操作时，这个计数器会被初始化，执行如下操作来得到计数器的值：&lt;/p>
&lt;p>&lt;code>select max(auto_inc_col) from t for update&lt;/code>&lt;/p>
&lt;p>插入操作会依据这个自增长的计数器值加 1 赋予自增长列。这个实现方式称为 &lt;code>Auto-Inc Locking&lt;/code>。这种锁其实是采用一种表锁的机制，为了提高插入的性能，&lt;strong>自增长锁不是在一个事务完成以后才释放，而是在完成自增长值插入的SQL后立即释放&lt;/strong>。&lt;/p>
&lt;p>虽然 &lt;code>Auto-Inc Locking&lt;/code> 从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。对于自增长列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成）。&lt;/p>
&lt;p>从 MySQL5.12 版本开始，InnoDB 存储引擎提供了一种轻量级互斥量的自增长实现方式。这种方式大大提高了自增长值插入的性能。并且从该版本开始，InnoDB 存储引起提供了一个参数 &lt;code>innodb_innodb_autoinc_lock_mode&lt;/code> 来控制自增长模式，该参数的默认值为 1&lt;/p>
&lt;p>自增长的插入分类:&lt;/p>
&lt;ul>
&lt;li>insert like: 指所有的插入语句，如 INSERT、REPLACE、INSERT&amp;hellip;SELECT、RPELACE&amp;hellip;SELECT、LOAD DATA等&lt;/li>
&lt;li>simple inserts：指能在插入前就确定插入行数的语句，如 INSERT、REPLACE 等。需要注意的是，不包含 INSERT&amp;hellip;ON DUPLICATE KEY
UPDATE 这类语句。&lt;/li>
&lt;li>bulk inserts：指在插入前不能确定插入行数的语句，如 INSERT&amp;hellip;SELECT、RPELACE&amp;hellip;SELECT、LOAD DATA等&lt;/li>
&lt;li>mixed-mode inserts：指插入中有一部分的值是自增长的，有一部分是确定的。如 INSERT INTO T1 (id,name) VALUES (1,&amp;lsquo;A&amp;rsquo;),(
NULL,&amp;lsquo;B&amp;rsquo;)；也可以指 INSERT&amp;hellip;ON DUPLICATE KEY UPDATE 这类语句。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>innodb_innodb_autoinc_lock_mode&lt;/code> 参数值的说明：&lt;/p>
&lt;ul>
&lt;li>0：
&lt;ol>
&lt;li>它提供了一个向后兼容的能力&lt;/li>
&lt;li>在这一模式下，所有的 insert 语句(&amp;ldquo;insert like&amp;rdquo;) 都要在语句开始的时候得到一个表级的 &lt;code>Auto-Inc Locking&lt;/code> 锁，在语句结束的时候才释放这把锁，注意呀，这里说的是语句级而不是事务级的，一个事务可能包涵有一个或多个语句。&lt;/li>
&lt;li>它能保证值分配的可预见性，与连续性，可重复性，这个也就保证了 insert 语句在复制到 slave 的时候还能生成和master那边一样的值(它保证了基于语句复制的安全)。&lt;/li>
&lt;li>由于在这种模式下 &lt;code>Auto-Inc Locking&lt;/code> 锁一直要保持到语句的结束，所以这个就影响到了并发的插入。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>1:
&lt;ol>
&lt;li>这一模式下去 simple insert 做了优化，由于simple insert一次性插入值的个数可以立马得到 确定，所以mysql可以一次生成几个连续的值，用于这个insert语句；总的来说这个对复制也是安全的(它保证了基于语句复制的安全)&lt;/li>
&lt;li>这一模式也是mysql的默认模式，这个模式的好处是 &lt;code>Auto-Inc Locking&lt;/code> 锁不要一直保持到语句的结束，只要语句得到了相应的值后就可以提前释放锁&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>2:
&lt;ol>
&lt;li>由于这个模式下已经没有了 &lt;code>Auto-Inc Locking&lt;/code> 锁，所以这个模式下的性能是最好的；但是它也有一个问题，就是对于同一个语句来说它所得到的 auto_incremant 值可能不是连续的。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>InnoDB 存储引擎中自增长的实现和 MyISAM 不同。MyISAM 存储引擎是表锁设计，自增长不用考虑并发插入的问题。在 InnoDB
存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列，如果不是第一个列，则 MySQL 会抛出异常。MyISAM 存储引擎没有这个问题。&lt;/p></description></item><item><title>Mysql ACID</title><link>https://ggxxll.github.io/p/mysql-acid/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://ggxxll.github.io/p/mysql-acid/</guid><description>&lt;h3 id="概述">概述&lt;/h3>
&lt;p>ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：
原子性（atomicity [ˌætəˈmɪsəti]， 或称不可分割性）、一致性（consistency [kənˈsɪstənsi]）、
隔离性（isolation [ˌaɪsəˈleɪʃn]，又称独立性）、持久性（durability [ˌdjʊərəˈbɪlɪti]）。&lt;/p>
&lt;p>在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。&lt;/p>
&lt;h3 id="特性">特性&lt;/h3>
&lt;ul>
&lt;li>Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。&lt;/li>
&lt;li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。&lt;/li>
&lt;li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read
uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。&lt;/li>
&lt;li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/li>
&lt;/ul>
&lt;h3 id="事务并发时可能出现的问题">事务并发时可能出现的问题&lt;/h3>
&lt;h4 id="脏读dirty-read">脏读（Dirty Read）&lt;/h4>
&lt;p>A 事务读到了 B 未提交事务修改过的数据&lt;/p>
&lt;h4 id="不可重复读non-repeatable-read">不可重复读（Non-Repeatable Read）&lt;/h4>
&lt;p>A 事务只能读到 B 已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，A 事务都能查询得到最新值。
（不可重复读在读未提交和读已提交隔离级别都可能会出现）&lt;/p>
&lt;h4 id="幻读phantom">幻读（Phantom）&lt;/h4>
&lt;p>A 事务先根据某些条件查询出一些记录，之后 B 事务又向表中插入了符合这些条件的记录，A 事务再次按照该条件查询时，能把 B 事务插入的记录也读出来。
（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）&lt;/p>
&lt;h3 id="mysql事务的隔离级别">Mysql事务的隔离级别&lt;/h3>
&lt;p>MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。&lt;/p>
&lt;p>MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。&lt;/p>
&lt;p>隔离级别比较：可串行化 &amp;gt; 可重复读 &amp;gt; 读已提交 &amp;gt; 读未提交&lt;/p>
&lt;p>隔离级别对性能的影响比较：可串行化 &amp;gt; 可重复读 &amp;gt; 读已提交 &amp;gt; 读未提交&lt;/p>
&lt;p>由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL Innodb默认的隔离级别也是可重复读。&lt;/p>
&lt;h4 id="读未提交read-uncommitted">读未提交（READ UNCOMMITTED）&lt;/h4>
&lt;p>在读未提交隔离级别下，事务 A 可以读取到事务 B 修改过但未提交的数据。&lt;/p>
&lt;p>可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。&lt;/p>
&lt;h4 id="读已提交read-committed">读已提交（READ COMMITTED）&lt;/h4>
&lt;p>在读已提交隔离级别下，事务 A 只能在事务 B 修改过并且已提交后才能读取到事务 B 修改的数据。&lt;/p>
&lt;p>读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。&lt;/p>
&lt;ol>
&lt;li>普通读是快照读；&lt;/li>
&lt;li>加锁的select, update, delete等语句，除了在外键约束检查(foreign-key constraint checking)以及重复键检查(duplicate-key checking)时会封锁区间，其他时刻都只使用记录锁；&lt;/li>
&lt;/ol>
&lt;h4 id="可重复读repeatable-read">可重复读（REPEATABLE READ）&lt;/h4>
&lt;p>在可重复读隔离级别下，事务 A 只能在事务 B 修改过数据并提交后，A 也提交事务后，才能读取到事务 B 修改的数据。&lt;/p>
&lt;p>可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。&lt;/p>
&lt;blockquote>
&lt;p>提问：为什么上了写锁（写操作），别的事务还可以读操作？&lt;/p>
&lt;/blockquote>
&lt;p>因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。&lt;/p>
&lt;ol>
&lt;li>普通的select使用快照读(snapshot read)，这是一种不加锁的一致性读(Consistent Nonlocking Read)，底层使用MVCC来实现，具体的原理在《InnoDB并发如此高，原因竟然在这？》中有详细的描述；&lt;/li>
&lt;li>加锁的select(&lt;code>select ... in share mode&lt;/code> | &lt;code>select ... for update&lt;/code>), update, delete等语句，它们的锁，依赖于它们是否在唯一索引(unique index)上使用了唯一的查询条件(unique search condition)，或者范围查询条件(range-type search condition)：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>在唯一索引上使用唯一的查询条件，会使用记录锁(record lock)，而不会封锁记录之间的间隔，即不会使用间隙锁(gap lock)与临键锁(next-key lock)&lt;/li>
&lt;li>范围查询条件，会使用间隙锁与临键锁，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录，以及避免不可重复的读&lt;/li>
&lt;/ul>
&lt;h4 id="可串行化serializable">可串行化（SERIALIZABLE）&lt;/h4>
&lt;p>各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。
事务并发执行时，阻塞情况与读写锁相同，可同时读，不可以读写交叉。&lt;/p>
&lt;p>所有select语句都会被隐式的转化为 &lt;code>select ... in share mode&lt;/code>.&lt;/p>
&lt;h3 id="隔离级别比较">隔离级别比较&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>级别&lt;/th>
&lt;th>脏读&lt;/th>
&lt;th>不可重复读&lt;/th>
&lt;th>幻读&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>读未提交&lt;/td>
&lt;td>可能&lt;/td>
&lt;td>可能&lt;/td>
&lt;td>可能&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>读已提交&lt;/td>
&lt;td>不会&lt;/td>
&lt;td>可能&lt;/td>
&lt;td>可能&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>可重复读&lt;/td>
&lt;td>不会&lt;/td>
&lt;td>不会&lt;/td>
&lt;td>可能&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>串行读&lt;/td>
&lt;td>不会&lt;/td>
&lt;td>不会&lt;/td>
&lt;td>不会&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="隔离级别的实现原理">隔离级别的实现原理&lt;/h3>
&lt;p>使用MySQL的默认隔离级别（可重复读）来进行说明。&lt;/p>
&lt;p>每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。
即通过回滚（rollback操作），可以回到前一个状态的值。&lt;/p>
&lt;p>提问：回滚操作日志（undo log）什么时候删除？&lt;/p>
&lt;p>MySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。&lt;/p>
&lt;p>提问：什么时候不需要了？&lt;/p>
&lt;p>当系统里么有比这个回滚日志更早的read-view的时候。&lt;/p>
&lt;h3 id="相关操作">相关操作&lt;/h3>
&lt;h4 id="查看隔离级别">查看隔离级别&lt;/h4>
&lt;ol>
&lt;li>&lt;code>SHOW VARIABLES LIKE 'transaction_isolation';&lt;/code>&lt;/li>
&lt;li>&lt;code>SELECT @@transaction_isolation;&lt;/code>&lt;/li>
&lt;/ol>
&lt;h4 id="设置隔离级别">设置隔离级别&lt;/h4>
&lt;h5 id="set-命令">SET 命令&lt;/h5>
&lt;p>&lt;code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">其中level有4种值：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">level: {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> REPEATABLE READ
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | READ COMMITTED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | READ UNCOMMITTED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | SERIALIZABLE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>1.　GLOBAL&lt;/p>
&lt;ul>
&lt;li>只对执行完该语句之后产生的会话起作用&lt;/li>
&lt;li>当前已经存在的会话无效&lt;/li>
&lt;/ul>
&lt;p>2.　SESSION&lt;/p>
&lt;ul>
&lt;li>只对当前会话中下一个即将开启的事务有效&lt;/li>
&lt;li>下一个事务执行完后，后续事务将恢复到之前的隔离级别&lt;/li>
&lt;li>该语句不能在已经开启的事务中间执行，会报错的&lt;/li>
&lt;/ul>
&lt;h5 id="服务启动项命令">服务启动项命令&lt;/h5>
&lt;p>可以修改启动参数transaction-isolation的值&lt;/p>
&lt;p>比方说我们在启动服务器时指定了&amp;ndash;transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。&lt;/p></description></item><item><title>Mysql order by 和 limit 语句导致慢 sql</title><link>https://ggxxll.github.io/p/mysql-order-by-%E5%92%8C-limit-%E8%AF%AD%E5%8F%A5%E5%AF%BC%E8%87%B4%E6%85%A2-sql/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://ggxxll.github.io/p/mysql-order-by-%E5%92%8C-limit-%E8%AF%AD%E5%8F%A5%E5%AF%BC%E8%87%B4%E6%85%A2-sql/</guid><description>&lt;h3 id="问题">问题&lt;/h3>
&lt;p>&lt;code>order by&lt;/code> 和 &lt;code>limit&lt;/code> 造成优化器选择索引错误&lt;/p>
&lt;h3 id="测试表">测试表&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DATABASE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">app&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">USE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">app&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">AUTO_INCREMENT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">varchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">CHARACTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">utf8mb4&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COLLATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">utf8mb4_0900_ai_ci&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">created_at&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">timestamp&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">deleted_at&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">timestamp&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">users_age_IDX&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">USING&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BTREE&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">InnoDB&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">AUTO_INCREMENT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CHARSET&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">utf8mb4&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COLLATE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">utf8mb4_0900_ai_ci&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="填充测试数据">填充测试数据&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">DROP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PROCEDURE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IF&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">EXISTS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">addData&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">DELIMITER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PROCEDURE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">addData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">IN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">BEGIN&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">DECLARE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DO&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">created_at&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">deleted_at&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">CONCAT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">null&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">End&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">while&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">END&lt;/span>&lt;span class="err">$$&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">DELIMITER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CALL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">addData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">400&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="查询-sql">查询 sql&lt;/h3>
&lt;ol>
&lt;li>以下查询中使用的索引正确使用了 &lt;code>users_age_IDX&lt;/code>。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">explain&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">limit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">explain&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">desc&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">limit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>select_type&lt;/th>
&lt;th>table&lt;/th>
&lt;th>partitions&lt;/th>
&lt;th>type&lt;/th>
&lt;th>possible_keys&lt;/th>
&lt;th>key&lt;/th>
&lt;th>key_len&lt;/th>
&lt;th>ref&lt;/th>
&lt;th>rows&lt;/th>
&lt;th>filtered&lt;/th>
&lt;th>Extra&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>SIMPLE&lt;/td>
&lt;td>u&lt;/td>
&lt;td>&lt;/td>
&lt;td>range&lt;/td>
&lt;td>users_age_IDX,users_deleted_at_IDX&lt;/td>
&lt;td>users_age_IDX&lt;/td>
&lt;td>5&lt;/td>
&lt;td>&lt;/td>
&lt;td>1988&lt;/td>
&lt;td>100.0&lt;/td>
&lt;td>Using index condition; Using where&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="2">
&lt;li>这个查询中使用的索引是主键, 数据量&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">explain&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">desc&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">limit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>select_type&lt;/th>
&lt;th>table&lt;/th>
&lt;th>partitions&lt;/th>
&lt;th>type&lt;/th>
&lt;th>possible_keys&lt;/th>
&lt;th>key&lt;/th>
&lt;th>key_len&lt;/th>
&lt;th>ref&lt;/th>
&lt;th>rows&lt;/th>
&lt;th>filtered&lt;/th>
&lt;th>Extra&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>SIMPLE&lt;/td>
&lt;td>u&lt;/td>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>users_age_IDX,users_deleted_at_IDX&lt;/td>
&lt;td>PRIMARY&lt;/td>
&lt;td>4&lt;/td>
&lt;td>&lt;/td>
&lt;td>65&lt;/td>
&lt;td>15.33&lt;/td>
&lt;td>Using where; Backward index scan&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="原因">原因&lt;/h3>
&lt;p>MySQL 优化器认为在 &lt;code>limit&lt;/code> 值较小的情况下，走主键索引能够更快的找到那一条数据，并且如果走联合索引需要扫描索引后进行排序，而主键索引天生有序，所以优化器综合考虑，走了主键索引。&lt;/p></description></item></channel></rss>