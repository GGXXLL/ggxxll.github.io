<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="基础知识 map的概念 map的直观意思是映射，是&amp;lt;key, value&amp;gt; 对组成的抽象结构，且 key 不会重复。map 的底层实现一般有两种：
搜索树（search tree），天然有序，平均/最差的写入/查找复杂度是O(logN) 哈希表（hash table），无序存储，平均的写入/查找复杂度是O(1)，最差是O(N) 底层 源码 在 golang 中，map 的底层实现是哈希表：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const ( bucketCntBits = 3 bucketCnt = 1 &amp;lt;&amp;lt; bucketCntBits ) type hmap struct { count int // map中存入元素的个数， golang 中调用 len(map) 的时候直接返回该字段 flags uint8 // 状态标记位，通过与定义的枚举值进行&amp;amp;操作可以判断当前是否处于这种状态 B uint8 // 2^B 表示 bucket 的数量， B 表示取hash后多少位来做 bucket 的分组 noverflow uint16 // overflow bucket 的数量的近似数 hash0 uint32 // hash seed （hash 种子） 一般是一个素数 buckets unsafe."><title>Golang Map</title><link rel=canonical href=https://ggxxll.github.io/p/golang-map/><link rel=stylesheet href=/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="Golang Map"><meta property="og:description" content="基础知识 map的概念 map的直观意思是映射，是&amp;lt;key, value&amp;gt; 对组成的抽象结构，且 key 不会重复。map 的底层实现一般有两种：
搜索树（search tree），天然有序，平均/最差的写入/查找复杂度是O(logN) 哈希表（hash table），无序存储，平均的写入/查找复杂度是O(1)，最差是O(N) 底层 源码 在 golang 中，map 的底层实现是哈希表：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const ( bucketCntBits = 3 bucketCnt = 1 &amp;lt;&amp;lt; bucketCntBits ) type hmap struct { count int // map中存入元素的个数， golang 中调用 len(map) 的时候直接返回该字段 flags uint8 // 状态标记位，通过与定义的枚举值进行&amp;amp;操作可以判断当前是否处于这种状态 B uint8 // 2^B 表示 bucket 的数量， B 表示取hash后多少位来做 bucket 的分组 noverflow uint16 // overflow bucket 的数量的近似数 hash0 uint32 // hash seed （hash 种子） 一般是一个素数 buckets unsafe."><meta property="og:url" content="https://ggxxll.github.io/p/golang-map/"><meta property="og:site_name" content="Trock"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="Golang"><meta property="article:published_time" content="2022-08-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-25T00:00:00+00:00"><meta name=twitter:title content="Golang Map"><meta name=twitter:description content="基础知识 map的概念 map的直观意思是映射，是&amp;lt;key, value&amp;gt; 对组成的抽象结构，且 key 不会重复。map 的底层实现一般有两种：
搜索树（search tree），天然有序，平均/最差的写入/查找复杂度是O(logN) 哈希表（hash table），无序存储，平均的写入/查找复杂度是O(1)，最差是O(N) 底层 源码 在 golang 中，map 的底层实现是哈希表：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const ( bucketCntBits = 3 bucketCnt = 1 &amp;lt;&amp;lt; bucketCntBits ) type hmap struct { count int // map中存入元素的个数， golang 中调用 len(map) 的时候直接返回该字段 flags uint8 // 状态标记位，通过与定义的枚举值进行&amp;amp;操作可以判断当前是否处于这种状态 B uint8 // 2^B 表示 bucket 的数量， B 表示取hash后多少位来做 bucket 的分组 noverflow uint16 // overflow bucket 的数量的近似数 hash0 uint32 // hash seed （hash 种子） 一般是一个素数 buckets unsafe."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=https://cdn.jsdelivr.net/gh/GGXXLL/BlogFiles@master/images/head.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Trock</a></h1><h2 class=site-description>吾之初心，永世不忘。</h2></div></header><ol class=social-menu><li><a href=https://github.com/ggxxll target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=/%E5%85%B3%E4%BA%8E/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索</span></a></li><li><a href=/%E5%8F%8B%E9%93%BE/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>友链</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#基础知识>基础知识</a><ol><li><a href=#map的概念>map的概念</a></li></ol></li><li><a href=#底层>底层</a><ol><li><a href=#源码>源码</a></li><li><a href=#hmap>hmap</a></li><li><a href=#bmap>bmap</a></li><li><a href=#mapextra>mapextra</a></li></ol></li><li><a href=#特性>特性</a><ol><li><a href=#引用类型>引用类型</a></li><li><a href=#非线程安全>非线程安全</a></li><li><a href=#共享存储空间>共享存储空间</a></li><li><a href=#哈希冲突>哈希冲突</a></li><li><a href=#遍历无序>遍历无序</a></li></ol></li><li><a href=#扩容>扩容</a><ol><li><a href=#扩容条件>扩容条件</a></li><li><a href=#扩容函数>扩容函数</a></li></ol></li><li><a href=#迁移>迁移</a><ol><li><a href=#迁移条件>迁移条件</a></li><li><a href=#迁移函数>迁移函数</a></li></ol></li><li><a href=#总结>总结</a><ol><li><a href=#参考>参考</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E5%90%8E%E7%AB%AF/ style=background-color:#2a9d8f;color:#fff>后端</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/golang-map/>Golang Map</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Aug 25, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 6 分钟</time></div></footer></div></header><section class=article-content><h2 id=基础知识>基础知识</h2><h3 id=map的概念>map的概念</h3><p>map的直观意思是映射，是&lt;key, value> 对组成的抽象结构，且 key 不会重复。map 的底层实现一般有两种：</p><ol><li>搜索树（search tree），天然有序，平均/最差的写入/查找复杂度是O(logN)</li><li>哈希表（hash table），无序存储，平均的写入/查找复杂度是O(1)，最差是O(N)</li></ol><h2 id=底层>底层</h2><h3 id=源码>源码</h3><p>在 golang 中，<a class=link href=https://github.com/golang/go/blob/master/src/runtime/map.go target=_blank rel=noopener>map</a> 的底层实现是哈希表：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>bucketCntBits</span> <span class=p>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>    <span class=nx>bucketCnt</span>     <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>bucketCntBits</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>hmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>count</span>     <span class=kt>int</span>    <span class=c1>// map中存入元素的个数， golang 中调用 len(map) 的时候直接返回该字段
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>flags</span>     <span class=kt>uint8</span>  <span class=c1>// 状态标记位，通过与定义的枚举值进行&amp;操作可以判断当前是否处于这种状态
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>B</span>         <span class=kt>uint8</span>  <span class=c1>// 2^B 表示 bucket 的数量， B 表示取hash后多少位来做 bucket 的分组
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>noverflow</span> <span class=kt>uint16</span> <span class=c1>// overflow bucket 的数量的近似数
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>hash0</span>     <span class=kt>uint32</span> <span class=c1>// hash seed （hash 种子） 一般是一个素数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>   <span class=nx>buckets</span>    <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 共有2^B个 bucket，但是如果没有元素存入，这个字段可能为nil
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>oldbuckets</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 在扩容期间，将旧的 bucket 数组放在这里， 新 bucket 会是这个的两倍大; 非扩容状态，值为 nil
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>nevacuate</span>  <span class=kt>uintptr</span>        <span class=c1>// 表示已经完成扩容迁移的bucket的指针， 地址小于当前指针的 bucket 已经迁移完成
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>   <span class=nx>extra</span> <span class=o>*</span><span class=nx>mapextra</span> <span class=c1>// 为了优化GC扫描而设计的。当 key 和 value 均不包含指针，并且都可以inline时使用。extra是指向 mapextra 类型的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A bucket for a Go map.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>tophash</span> <span class=p>[</span><span class=nx>bucketCnt</span><span class=p>]</span><span class=kt>uint8</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 编译期间会给它加料，动态地创建一个新的结构：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 长度为8的数组，用来快速定位 key 是否在桶里
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>topbits</span>  <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=kt>uint8</span>
</span></span><span class=line><span class=cl>    <span class=nx>keys</span>     <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=nx>keytype</span>
</span></span><span class=line><span class=cl>    <span class=nx>values</span>   <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=nx>valuetype</span>
</span></span><span class=line><span class=cl>    <span class=nx>pad</span>      <span class=kt>uintptr</span>        <span class=c1>// 内存对齐使用，可能不需要
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>overflow</span> <span class=kt>uintptr</span>        <span class=c1>// 当 bucket 的8个key 存满了之后
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=hmap>hmap</h3><p>map 的底层结构是 hmap，hmap 包含若干个结构为 bmap 的 bucket 数组，每个 bucket 底层都采用链表结构。</p><h3 id=bmap>bmap</h3><p>bmap 就是我们常说的“桶”的底层数据结构， 一个桶中可以存放最多 8 个 key/value, map 使用 hash 函数 得到 hash 值决定分配到哪个桶，
然后又会根据 hash 值的高 8 位来寻找放在桶的哪个位置。具体的 map 的组成结构如下图所示：</p><p>bmap 中 key 和 value 是各自放在一起的，并不是 key/value/key/value/&mldr; 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。</p><h3 id=mapextra>mapextra</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// mapextra holds fields that are not present on all maps.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>mapextra</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果 key 和 value 都不包含指针，并且可以被 inline(&lt;=128 字节)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 就使用 hmap 的 extra 字段 来存储 overflow buckets，这样可以避免 GC 扫描整个 map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 然而 bmap.overflow 也是个指针。这时候我们只能把这些 overflow 的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 都放在 hmap.extra.overflow 和 hmap.extra.oldoverflow 中了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// overflow 包含的是 hmap.buckets 的 overflow 的 buckets
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// oldoverflow 包含扩容时的 hmap.oldbuckets 的 overflow 的 bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>overflow</span>    <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span>
</span></span><span class=line><span class=cl>    <span class=nx>oldoverflow</span> <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 指向空闲的 overflow bucket 的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nextOverflow</span> <span class=o>*</span><span class=nx>bmap</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=特性>特性</h2><h3 id=引用类型>引用类型</h3><p>map是个指针，底层指向hmap，所以是个引用类型。
golang 有三个常用的高级类型slice、map、channel，它们都是引用类型，当引用类型作为函数参数时，可能会修改原内容数据。
golang 中没有引用传递，只有值和指针传递。所以 map 作为函数实参传递时本质上也是值传递，只不过因为 map 底层数据结构是通过指针指向实际的元素存储空间，
在被调函数中修改 map，对调用者同样可见，所以 map 作为函数实参传递时表现出了引用传递的效果。
因此，传递 map 时，如果想修改map的内容而不是map本身，函数形参无需使用指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestSliceFn</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// map[a:1]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mapAppend</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// map[a:1 b:2] 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mapAppend</span><span class=p>(</span><span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=非线程安全>非线程安全</h3><p>map默认是并发不安全的，原因如下：</p><p>Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景（不需要从多个 goroutine 中进行安全访问），而不是为了小部分情况（并发访问），导致大部分程序付出加锁代价（性能），决定了不支持。</p><p>更改 map 时会检查 hmap 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic。这也说明了 map 对协程是不安全的。</p><h3 id=共享存储空间>共享存储空间</h3><p>map 底层数据结构是通过指针指向实际的元素存储空间 ，这种情况下，对其中一个map的更改，会影响到其他map</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestMapShareMemory</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m1</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>m2</span> <span class=o>:=</span> <span class=nx>m1</span>
</span></span><span class=line><span class=cl>    <span class=nx>m1</span><span class=p>[</span><span class=s>&#34;a&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=nx>m1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// map[a:1] 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=nx>m2</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// map[a:1]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=哈希冲突>哈希冲突</h3><p>golang中map是一个kv对集合。底层使用hash table，用链表来解决冲突 ，出现冲突时，不是每一个key都申请一个结构通过链表串起来，
而是以bmap为最小粒度挂载，一个bmap可以放8个kv。在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。</p><h3 id=遍历无序>遍历无序</h3><p>map 在没有被修改的情况下，使用 range 多次遍历 map 时输出的 key 和 value 的顺序可能不同。这是 Go 语言的设计者们有意为之，
在每次 range 时的顺序被随机化，旨在提示开发者们，Go 底层实现并不保证 map 遍历顺序稳定，请大家不要依赖 range 遍历结果顺序。</p><h2 id=扩容>扩容</h2><h3 id=扩容条件>扩容条件</h3><p>再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// If we hit the max load factor or we have too many overflow buckets,
</span></span></span><span class=line><span class=cl><span class=c1>// and we&#39;re not already in the middle of growing, start growing.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=o>||</span> <span class=nf>tooManyOverflowBuckets</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>noverflow</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>hashGrow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=nx>again</span> <span class=c1>// Growing the table invalidates everything, so try again
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol><li><p>装载因子超过阈值</p><p>源码里定义的阈值是 6.5 (loadFactorNum/loadFactorDen)，是经过测试后取出的一个比较合理的因子。
我们知道，每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，
表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。</p><p>对于条件 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量(2^B)直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。</p><p>注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。新 bucket 只是最大数量变为原来最大数量的 2 倍(2^B * 2) 。</p></li><li><p>overflow 的 bucket 数量过多</p><p>在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，
即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。</p><p>不难想像造成这种情况的原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。
之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，但就是不会触发第 1 点的规定，你能拿我怎么办？
overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人，因此出台第 2 点规定。</p><p>这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。</p><p>对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，
将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。
结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。</p></li></ol><h3 id=扩容函数>扩容函数</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hashGrow</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If we&#39;ve hit the load factor, get bigger.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Otherwise, there are too many overflow buckets,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// so keep the same number of buckets and &#34;grow&#34; laterally.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>bigger</span> <span class=o>:=</span> <span class=nb>uint8</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>bigger</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>|=</span> <span class=nx>sameSizeGrow</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>oldbuckets</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span>
</span></span><span class=line><span class=cl>    <span class=nx>newbuckets</span><span class=p>,</span> <span class=nx>nextOverflow</span> <span class=o>:=</span> <span class=nf>makeBucketArray</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=o>+</span><span class=nx>bigger</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>flags</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>&amp;^</span> <span class=p>(</span><span class=nx>iterator</span> <span class=p>|</span> <span class=nx>oldIterator</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>iterator</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>flags</span> <span class=o>|=</span> <span class=nx>oldIterator</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// commit the grow (atomic wrt gc)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>h</span><span class=p>.</span><span class=nx>B</span> <span class=o>+=</span> <span class=nx>bigger</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=p>=</span> <span class=nx>flags</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span> <span class=p>=</span> <span class=nx>oldbuckets</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span> <span class=p>=</span> <span class=nx>newbuckets</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>noverflow</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Promote current overflow buckets to the old generation.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>oldoverflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;oldoverflow is not nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>oldoverflow</span> <span class=p>=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>nextOverflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>mapextra</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>nextOverflow</span> <span class=p>=</span> <span class=nx>nextOverflow</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// the actual copying of the hash table data is done incrementally
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// by growWork() and evacuate().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p><p>上面说的 hashGrow() 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 growWork() 函数中，而调用 growWork() 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p><h2 id=迁移>迁移</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>growWork</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>bucket</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// make sure we evacuate the oldbucket corresponding
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// to the bucket we&#39;re about to use
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>evacuate</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>bucket</span><span class=o>&amp;</span><span class=nx>h</span><span class=p>.</span><span class=nf>oldbucketmask</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// evacuate one more oldbucket to make progress on growing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>evacuate</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=迁移条件>迁移条件</h3><p>如果未迁移完毕，赋值/删除的时候，扩容完毕后（预分配内存），不会马上就进行迁移。而是采取增量扩容的方式，当有访问到具体 bukcet 时，才会逐渐的进行迁移（将 oldbucket 迁移到 bucket）</p><h3 id=迁移函数>迁移函数</h3><p>hmap.nevacuate 标识的是当前的进度，如果都搬迁完，应该和2^B的长度是一样的
在evacuate 方法实现是把这个位置对应的 bucket，以及其冲突链上的数据都转移到新的 bucket 上。</p><ol><li><p>先要判断当前 bucket 是不是已经转移。 (oldbucket 标识需要搬迁的 bucket 对应的位置)。转移的判断直接通过tophash 就可以，判断 tophash 中第一个 hash 值即可</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>emptyOne</span>       <span class=p>=</span> <span class=mi>1</span> <span class=c1>// this cell is empty
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>minTopHash</span>     <span class=p>=</span> <span class=mi>5</span> <span class=c1>// minimum tophash for a normal filled cell.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>evacuated</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>bmap</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>h</span> <span class=p>&gt;</span> <span class=nx>emptyOne</span> <span class=o>&amp;&amp;</span> <span class=nx>h</span> <span class=p>&lt;</span> <span class=nx>minTopHash</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>如果没有被转移，那就要迁移数据了。数据迁移时，可能是迁移到大小相同的 buckets 上，也可能迁移到2倍大的 buckets 上。这里 xy 都是标记目标迁移位置的标记：x 标识的是迁移到相同的位置，y 标识的是迁移到2倍大的位置上。我们先看下目标位置的确定：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>xy</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=nx>evacDst</span>
</span></span><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>xy</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>x</span><span class=p>.</span><span class=nx>b</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>oldbucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=nx>x</span><span class=p>.</span><span class=nx>k</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>x</span><span class=p>.</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>x</span><span class=p>.</span><span class=nx>e</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>x</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>sameSizeGrow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Only calculate y pointers if we&#39;re growing bigger.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Otherwise GC can see bad pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>y</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>xy</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>y</span><span class=p>.</span><span class=nx>b</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=p>(</span><span class=nx>oldbucket</span><span class=o>+</span><span class=nx>newbit</span><span class=p>)</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>y</span><span class=p>.</span><span class=nx>k</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>y</span><span class=p>.</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>y</span><span class=p>.</span><span class=nx>e</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>y</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>确定bucket位置后，需要按照kv 一条一条做迁移。</p></li><li><p>如果当前搬迁的bucket 和 总体搬迁的bucket的位置是一样的，我们需要更新总体进度的标记 nevacuate</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>advanceEvacuationMark</span><span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>newbit</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Experiments suggest that 1024 is overkill by at least an order of magnitude.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Put it in there as a safeguard anyway, to ensure O(1) behavior.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>stop</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=o>+</span> <span class=mi>1024</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>stop</span> <span class=p>&gt;</span> <span class=nx>newbit</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>stop</span> <span class=p>=</span> <span class=nx>newbit</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=o>!=</span> <span class=nx>stop</span> <span class=o>&amp;&amp;</span> <span class=nf>bucketEvacuated</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=o>==</span> <span class=nx>newbit</span> <span class=p>{</span> <span class=c1>// newbit == # of oldbuckets
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Growing is all done. Free old main bucket array.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Can discard old overflow buckets as well.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// If they are still referenced by an iterator,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// then the iterator holds a pointers to the slice.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>oldoverflow</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>&amp;^=</span> <span class=nx>sameSizeGrow</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h2 id=总结>总结</h2><ul><li>map是引用类型</li><li>map遍历是无序的</li><li>map是非线程安全的</li><li>map的哈希冲突解决方式是链表法</li><li>map的扩容不是一定会新增空间，也有可能是只是做了内存整理</li><li>map的迁移是逐步进行的，在每次赋值时，会做至少一次迁移工作</li><li>map中删除key，有可能导致出现很多空的kv，这会导致迁移操作，如果可以避免，尽量避免</li></ul><h3 id=参考>参考</h3><p><a class=link href=https://www.cnblogs.com/cnblogs-wangzhipeng/p/13292524.html target=_blank rel=noopener>https://www.cnblogs.com/cnblogs-wangzhipeng/p/13292524.html</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/golang/>Golang</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/golang-gmp/><div class=article-details><h2 class=article-title>Golang GMP</h2></div></a></article><article><a href=/p/golang-slice/><div class=article-details><h2 class=article-title>Golang Slice</h2></div></a></article><article><a href=/p/gin-opentracing%E7%9A%84%E4%BD%BF%E7%94%A8/><div class=article-details><h2 class=article-title>gin+opentracing的使用</h2></div></a></article><article><a href=/p/%E4%BD%BF%E7%94%A8-map-%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98/><div class=article-details><h2 class=article-title>使用 map 设计缓存</h2></div></a></article><article><a href=/p/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BDbug/><div class=article-details><h2 class=article-title>文件下载Bug</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 Trock</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>