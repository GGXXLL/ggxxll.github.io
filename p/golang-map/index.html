<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="基础知识 map的概念 map的直观意思是映射，是&amp;lt;key, value&amp;gt; 对组成的抽象结构，且 key 不会重复。map 的底层实现一般有两种：
搜索树（search tree），天然有序，平均/最差的写入/查找复杂度是O(logN) 哈希表（hash table），无序存储，平均的写入/查找复杂度是O(1)，最差是O(N) 底层 源码 在 golang 中，map 的底层实现是哈希表：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const ( bucketCntBits = 3 bucketCnt = 1 &amp;lt;&amp;lt; bucketCntBits ) type hmap struct { count int // map中存入元素的个数， golang 中调用 len(map) 的时候直接返回该字段 flags uint8 // 状态标记位，通过与定义的枚举值进行&amp;amp;操作可以判断当前是否处于这种状态 B uint8 // 2^B 表示 bucket 的数量， B 表示取hash后多少位来做 bucket 的分组 noverflow uint16 // overflow bucket 的数量的近似数 hash0 uint32 // hash seed （hash 种子） 一般是一个素数 buckets unsafe."><title>Golang Map</title><link rel=canonical href=https://ggxxll.github.io/p/golang-map/><link rel=stylesheet href=/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="Golang Map"><meta property="og:description" content="基础知识 map的概念 map的直观意思是映射，是&amp;lt;key, value&amp;gt; 对组成的抽象结构，且 key 不会重复。map 的底层实现一般有两种：
搜索树（search tree），天然有序，平均/最差的写入/查找复杂度是O(logN) 哈希表（hash table），无序存储，平均的写入/查找复杂度是O(1)，最差是O(N) 底层 源码 在 golang 中，map 的底层实现是哈希表：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const ( bucketCntBits = 3 bucketCnt = 1 &amp;lt;&amp;lt; bucketCntBits ) type hmap struct { count int // map中存入元素的个数， golang 中调用 len(map) 的时候直接返回该字段 flags uint8 // 状态标记位，通过与定义的枚举值进行&amp;amp;操作可以判断当前是否处于这种状态 B uint8 // 2^B 表示 bucket 的数量， B 表示取hash后多少位来做 bucket 的分组 noverflow uint16 // overflow bucket 的数量的近似数 hash0 uint32 // hash seed （hash 种子） 一般是一个素数 buckets unsafe."><meta property="og:url" content="https://ggxxll.github.io/p/golang-map/"><meta property="og:site_name" content="Trock"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="Golang"><meta property="article:published_time" content="2022-08-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-25T00:00:00+00:00"><meta name=twitter:title content="Golang Map"><meta name=twitter:description content="基础知识 map的概念 map的直观意思是映射，是&amp;lt;key, value&amp;gt; 对组成的抽象结构，且 key 不会重复。map 的底层实现一般有两种：
搜索树（search tree），天然有序，平均/最差的写入/查找复杂度是O(logN) 哈希表（hash table），无序存储，平均的写入/查找复杂度是O(1)，最差是O(N) 底层 源码 在 golang 中，map 的底层实现是哈希表：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const ( bucketCntBits = 3 bucketCnt = 1 &amp;lt;&amp;lt; bucketCntBits ) type hmap struct { count int // map中存入元素的个数， golang 中调用 len(map) 的时候直接返回该字段 flags uint8 // 状态标记位，通过与定义的枚举值进行&amp;amp;操作可以判断当前是否处于这种状态 B uint8 // 2^B 表示 bucket 的数量， B 表示取hash后多少位来做 bucket 的分组 noverflow uint16 // overflow bucket 的数量的近似数 hash0 uint32 // hash seed （hash 种子） 一般是一个素数 buckets unsafe."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=https://cdn.jsdelivr.net/gh/GGXXLL/BlogFiles@master/images/head.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Trock</a></h1><h2 class=site-description>吾之初心，永世不忘。</h2></div></header><ol class=social-menu><li><a href=https://github.com/ggxxll target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=/%E5%85%B3%E4%BA%8E/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/%E5%8F%8B%E9%93%BE/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>友链</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索</span></a></li><li><a href=/book/><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><path fill="currentcolor" d="M101.667 4e2H464V16H100.667A60.863 60.863.0 0040 76.667V430.25h.011c0 .151-.011.3-.011.453.0 35.4 27.782 65.3 60.667 65.3H464V464H100.667C85.664 464 72 448.129 72 430.7c0-16.64 13.585-30.7 29.667-30.7zM360 48.333v172.816l-48.4-42.49L264 220.9V48.333zM232 48v216h31.641l48.075-42.659L360.305 264H392V48h40v320H136.08L136 48zm-131.333.0H104l.076 320h-2.413A59.793 59.793.0 0072 375.883V76.917A28.825 28.825.0 01100.667 48z"/></svg><span>书籍</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#基础知识>基础知识</a><ol><li><a href=#map的概念>map的概念</a></li></ol></li><li><a href=#底层>底层</a><ol><li><a href=#源码>源码</a></li><li><a href=#hmap>hmap</a></li><li><a href=#bmap>bmap</a></li><li><a href=#mapextra>mapextra</a></li><li><a href=#操作>操作</a><ol><li><a href=#查找-key>查找 Key</a></li><li><a href=#插入-key>插入 Key</a></li><li><a href=#删除-key>删除 Key</a></li></ol></li></ol></li><li><a href=#特性>特性</a><ol><li><a href=#引用类型>引用类型</a></li><li><a href=#非线程安全>非线程安全</a></li><li><a href=#共享存储空间>共享存储空间</a></li><li><a href=#哈希冲突>哈希冲突</a></li><li><a href=#遍历无序>遍历无序</a></li></ol></li><li><a href=#扩容>扩容</a><ol><li><a href=#扩容条件>扩容条件</a></li><li><a href=#扩容函数>扩容函数</a></li></ol></li><li><a href=#迁移>迁移</a><ol><li><a href=#迁移条件>迁移条件</a></li><li><a href=#迁移函数>迁移函数</a></li></ol></li><li><a href=#总结>总结</a><ol><li><a href=#参考>参考</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E5%90%8E%E7%AB%AF/ style=background-color:#2a9d8f;color:#fff>后端</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/golang-map/>Golang Map</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Aug 25, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 12 分钟</time></div></footer></div></header><section class=article-content><h2 id=基础知识>基础知识</h2><h3 id=map的概念>map的概念</h3><p>map的直观意思是映射，是&lt;key, value> 对组成的抽象结构，且 key 不会重复。map 的底层实现一般有两种：</p><ol><li>搜索树（search tree），天然有序，平均/最差的写入/查找复杂度是O(logN)</li><li>哈希表（hash table），无序存储，平均的写入/查找复杂度是O(1)，最差是O(N)</li></ol><h2 id=底层>底层</h2><h3 id=源码>源码</h3><p>在 golang 中，<a class=link href=https://github.com/golang/go/blob/master/src/runtime/map.go target=_blank rel=noopener>map</a> 的底层实现是哈希表：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>bucketCntBits</span> <span class=p>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>    <span class=nx>bucketCnt</span>     <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>bucketCntBits</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>hmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>count</span>     <span class=kt>int</span>    <span class=c1>// map中存入元素的个数， golang 中调用 len(map) 的时候直接返回该字段
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>flags</span>     <span class=kt>uint8</span>  <span class=c1>// 状态标记位，通过与定义的枚举值进行&amp;操作可以判断当前是否处于这种状态
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>B</span>         <span class=kt>uint8</span>  <span class=c1>// 2^B 表示 bucket 的数量， B 表示取hash后多少位来做 bucket 的分组
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>noverflow</span> <span class=kt>uint16</span> <span class=c1>// overflow bucket 的数量的近似数
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>hash0</span>     <span class=kt>uint32</span> <span class=c1>// hash seed （hash 种子） 一般是一个素数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>   <span class=nx>buckets</span>    <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 共有2^B个 bucket，但是如果没有元素存入，这个字段可能为nil
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>oldbuckets</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 在扩容期间，将旧的 bucket 数组放在这里， 新 bucket 会是这个的两倍大; 非扩容状态，值为 nil
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>nevacuate</span>  <span class=kt>uintptr</span>        <span class=c1>// 表示已经完成扩容迁移的bucket的指针， 地址小于当前指针的 bucket 已经迁移完成
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>   <span class=nx>extra</span> <span class=o>*</span><span class=nx>mapextra</span> <span class=c1>// 为了优化GC扫描而设计的。当 key 和 value 均不包含指针，并且都可以inline时使用。extra是指向 mapextra 类型的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A bucket for a Go map.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>tophash</span> <span class=p>[</span><span class=nx>bucketCnt</span><span class=p>]</span><span class=kt>uint8</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 编译期间会给它加料，动态地创建一个新的结构：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 长度为8的数组，用来快速定位 key 是否在桶里
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>topbits</span>  <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=kt>uint8</span>
</span></span><span class=line><span class=cl>    <span class=nx>keys</span>     <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=nx>keytype</span>
</span></span><span class=line><span class=cl>    <span class=nx>values</span>   <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=nx>valuetype</span>
</span></span><span class=line><span class=cl>    <span class=nx>pad</span>      <span class=kt>uintptr</span>        <span class=c1>// 内存对齐使用，可能不需要
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>overflow</span> <span class=kt>uintptr</span>        <span class=c1>// 当 bucket 的8个key 存满了之后
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=hmap>hmap</h3><p>map 的底层结构是 hmap，hmap 包含若干个结构为 bmap 的 bucket 数组，每个 bucket 底层都采用链表结构。</p><h3 id=bmap>bmap</h3><p>bmap 就是我们常说的“桶”的底层数据结构， 一个桶中可以存放最多 8 个 key/value, map 使用 hash 函数计算 hash 值。hash 值的低 8 位决定存放到第几个桶，
高 8 位来决定存放到桶中 tophash 数组的第几位。具体的 map 的组成结构如下图所示：</p><p>bmap 中 key 和 value 是各自放在一起的 <code>bmap.keys</code> 和 <code>bmap.values</code>，并不是 <code>key/value/key/value/...</code> 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。</p><blockquote><p>使用 <code>key/value/key/value/...</code> 结构，如果存储的键和值的类型不同，在内存中布局中所占字节不同的话，就需要对齐。比如说存储一个 <code>map[int64]int8</code> 类型的字典。</p></blockquote><h3 id=mapextra>mapextra</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// mapextra holds fields that are not present on all maps.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>mapextra</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果 key 和 value 都不包含指针，并且可以被 inline(&lt;=128 字节)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 就使用 hmap 的 extra 字段 来存储 overflow buckets，这样可以避免 GC 扫描整个 map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 然而 bmap.overflow 也是个指针。这时候我们只能把这些 overflow 的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 都放在 hmap.extra.overflow 和 hmap.extra.oldoverflow 中了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// overflow 包含的是 hmap.buckets 的 overflow 的 buckets
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// oldoverflow 包含扩容时的 hmap.oldbuckets 的 overflow 的 bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>overflow</span>    <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span>
</span></span><span class=line><span class=cl>    <span class=nx>oldoverflow</span> <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 指向空闲的 overflow bucket 的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nextOverflow</span> <span class=o>*</span><span class=nx>bmap</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=操作>操作</h3><h4 id=查找-key>查找 Key</h4><p>首先计算出 key 对应的 hash 值，hash 值对 B 取余。</p><p>hash 的低 8 位决定了桶数组里面的第几个桶，hash 值的高8位决定了这个桶数组 bmap 里面 key 存在 tophash 数组的第几位了。hash 的高 8 位用来和 tophash 数组里面的每个值进行对比，如果高 8 位和 tophash[i] 不等，就直接比下一个。如果相等，则取出 bmap 里面对应完整的 key，再比较一次，看是否完全一致。</p><p>整个查找过程优先在 oldbucket 里面找(如果存在 oldbucket 的话)，找完再去新 bmap 里面找。</p><p>有人可能会有疑问，为何这里要加入 tophash 多一次比较呢？</p><p>tophash 的引入是为了加速查找的。由于它只存了 hash 值的高 8 位，比查找完整的 64 位要快很多。通过比较高 8 位，迅速找到高 8 位一致 hash 值的索引，接下来再进行一次完整的比较，如果还一致，那么就判定找到该 key 了。</p><p>如果找到了 key 就返回对应的 value。如果没有找到，还会继续去 overflow 桶继续寻找，直到找到最后一个桶，如果还没有找到就返回对应类型的零值。</p><h4 id=插入-key>插入 Key</h4><p>插入 key 的过程和查找 key 的过程大体一致。</p><p>有几点不同，需要注意：</p><ol><li>如果找到要插入的 key ，只需要直接更新对应的 value 值就好了。</li><li>如果没有在 bmap 中没有找到待插入的 key ，这么这时分几种情况。</li></ol><ul><li>bmap 中还有空位，在遍历 bmap 的时候预先标记空位，一旦查找结束也没有找到 key，就把 key 放到预先遍历时候标记的空位上。</li><li>bmap中已经没有空位了。这个时候 bmap 装的很满了。此时需要检查一次最大负载因子是否已经达到了。如果达到了，立即进行扩容操作。扩容以后在新桶里面插入 key，流程和上述的一致。如果没有达到最大负载因子，那么就在新生成一个 bmap，并把前一个 bmap 的 overflow 指针指向新的 bmap。</li></ul><ol start=3><li>在扩容过程中，oldbucket 是被冻结的，查找 key 时会在oldbucket 中查找，但不会在 oldbucket 中插入数据。如果在 oldbucket 是找到了相应的 key，做法是将它迁移到新 bmap 后加入 evalucated 标记。</li></ol><h4 id=删除-key>删除 Key</h4><p>删除操作主要流程和查找 key 流程也差不多，找到对应的 key 以后，如果是指针指向原来的 key，就把指针置为 nil，如果是值就清空它所在的内存。还要清理 tophash 里面的值，最后把 hmap 的 count 减 1。</p><p>如果在扩容过程中，删除操作会在扩容以后在新的 bmap 里面执行删除。</p><p>查找的过程依旧会一直遍历到链表的最后一个 bmap 桶。</p><h2 id=特性>特性</h2><h3 id=引用类型>引用类型</h3><p>map是个指针，底层指向hmap，所以是个引用类型。</p><p>golang 有三个常用的高级类型 slice、map、channel，它们都是引用类型，当引用类型作为函数参数时，可能会修改原内容数据。</p><p>golang 中没有引用传递，只有值和指针传递。所以 map 作为函数实参传递时本质上也是值传递，只不过因为 map 底层数据结构是通过指针指向实际的元素存储空间，
在被调函数中修改 map，对调用者同样可见，所以 map 作为函数实参传递时表现出了引用传递的效果。</p><p>因此，传递 map 时，如果想修改map的内容而不是map本身，函数形参无需使用指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestSliceFn</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// map[a:1]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mapAppend</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// map[a:1 b:2] 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mapAppend</span><span class=p>(</span><span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=非线程安全>非线程安全</h3><p>map默认是并发不安全的，原因如下：</p><p>Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景（不需要从多个 goroutine 中进行安全访问），而不是为了小部分情况（并发访问），导致大部分程序付出加锁代价（性能），决定了不支持。</p><p>更改 map 时会检查 hmap 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic。这也说明了 map 对协程是不安全的。</p><h3 id=共享存储空间>共享存储空间</h3><p>map 底层数据结构是通过指针指向实际的元素存储空间 ，这种情况下，对其中一个map的更改，会影响到其他map</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestMapShareMemory</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m1</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>m2</span> <span class=o>:=</span> <span class=nx>m1</span>
</span></span><span class=line><span class=cl>    <span class=nx>m1</span><span class=p>[</span><span class=s>&#34;a&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=nx>m1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// map[a:1] 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=nx>m2</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// map[a:1]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=哈希冲突>哈希冲突</h3><p>golang中map是一个 kv 对集合。底层使用 hash table，用链表来解决冲突 ，出现冲突时，不是每一个 key 都申请一个结构通过链表串起来，
而是以 bmap 为最小粒度挂载，一个 bmap 可以放 8 个 kv。</p><p>在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。</p><h3 id=遍历无序>遍历无序</h3><p>map 在没有被修改的情况下，使用 range 多次遍历 map 时输出的 key 和 value 的顺序可能不同。这是 Go 语言的设计者们有意为之，
在每次 range 时的顺序被随机化，旨在提示开发者们，Go 底层实现并不保证 map 遍历顺序稳定，请大家不要依赖 range 遍历结果顺序。</p><h2 id=扩容>扩容</h2><h3 id=扩容条件>扩容条件</h3><p>再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// If we hit the max load factor or we have too many overflow buckets,
</span></span></span><span class=line><span class=cl><span class=c1>// and we&#39;re not already in the middle of growing, start growing.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=o>||</span> <span class=nf>tooManyOverflowBuckets</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>noverflow</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>hashGrow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=nx>again</span> <span class=c1>// Growing the table invalidates everything, so try again
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>tooManyOverflowBuckets</span><span class=p>(</span><span class=nx>noverflow</span> <span class=kt>uint16</span><span class=p>,</span> <span class=nx>B</span> <span class=kt>uint8</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// If the threshold is too low, we do extraneous work.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// &#34;too many&#34; means (approximately) as many overflow buckets as regular buckets.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// See incrnoverflow for more details.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>B</span> <span class=p>&gt;</span> <span class=mi>15</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>B</span> <span class=p>=</span> <span class=mi>15</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The compiler doesn&#39;t see here that B &lt; 16; mask B to generate shorter shift code.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nx>noverflow</span> <span class=o>&gt;=</span> <span class=nb>uint16</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=nx>B</span><span class=o>&amp;</span><span class=mi>15</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol><li><p>装载因子超过阈值</p><p>源码里定义的阈值是 6.5 (<code>loadFactorNum/loadFactorDen</code>)，是经过测试后取出的一个比较合理的因子。
我们知道，每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，
表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。</p><p>对于条件 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量(2^B)直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。</p><p>注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。新 bucket 只是最大数量变为原来最大数量的 2 倍(2^B * 2) 。</p></li><li><p>overflow 的 bucket 数量过多<br>在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，
即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。</p><p>不难想像造成这种情况的原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。
之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，但就是不会触发第 1 点的规定，你能拿我怎么办？
overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人，因此出台第 2 点规定。</p><p>这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。</p><p>对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，
将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。
结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。</p></li></ol><h3 id=扩容函数>扩容函数</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hashGrow</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If we&#39;ve hit the load factor, get bigger.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Otherwise, there are too many overflow buckets,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// so keep the same number of buckets and &#34;grow&#34; laterally.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>bigger</span> <span class=o>:=</span> <span class=nb>uint8</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>bigger</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>|=</span> <span class=nx>sameSizeGrow</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>oldbuckets</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span>
</span></span><span class=line><span class=cl>    <span class=nx>newbuckets</span><span class=p>,</span> <span class=nx>nextOverflow</span> <span class=o>:=</span> <span class=nf>makeBucketArray</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=o>+</span><span class=nx>bigger</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>flags</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>&amp;^</span> <span class=p>(</span><span class=nx>iterator</span> <span class=p>|</span> <span class=nx>oldIterator</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>iterator</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>flags</span> <span class=o>|=</span> <span class=nx>oldIterator</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// commit the grow (atomic wrt gc)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>h</span><span class=p>.</span><span class=nx>B</span> <span class=o>+=</span> <span class=nx>bigger</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=p>=</span> <span class=nx>flags</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span> <span class=p>=</span> <span class=nx>oldbuckets</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span> <span class=p>=</span> <span class=nx>newbuckets</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>noverflow</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Promote current overflow buckets to the old generation.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>oldoverflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;oldoverflow is not nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>oldoverflow</span> <span class=p>=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>nextOverflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>mapextra</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>nextOverflow</span> <span class=p>=</span> <span class=nx>nextOverflow</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// the actual copying of the hash table data is done incrementally
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// by growWork() and evacuate().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p><p>上面说的 <code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 <code>mapassign</code> 和 <code>mapdelete</code> 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p><h2 id=迁移>迁移</h2><p><code>hashGrow</code> 操作算是扩容之前的准备工作，实际拷贝的过程在 <code>evacuate</code> 中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>growWork</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>bucket</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// make sure we evacuate the oldbucket corresponding
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// to the bucket we&#39;re about to use
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>evacuate</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>bucket</span><span class=o>&amp;</span><span class=nx>h</span><span class=p>.</span><span class=nf>oldbucketmask</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// evacuate one more oldbucket to make progress on growing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>evacuate</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=迁移条件>迁移条件</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>evacuate</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>oldbucket</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span><span class=p>,</span> <span class=nx>oldbucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 在准备扩容之前桶的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>newbit</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nf>noldbuckets</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>alg</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>.</span><span class=nx>alg</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nf>evacuated</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// TODO: reuse overflow buckets instead of using new ones, if there
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// is no iterator using the old buckets.  (If !oldIterator.)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>			<span class=nx>x</span><span class=p>,</span> <span class=nx>y</span>   <span class=o>*</span><span class=nx>bmap</span>          <span class=c1>// 在新桶里面 低位桶和高位桶
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>xi</span><span class=p>,</span> <span class=nx>yi</span> <span class=kt>int</span>            <span class=c1>// key 和 value 值的索引值分别为 xi ， yi 
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>xk</span><span class=p>,</span> <span class=nx>yk</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 指向 x 和 y 的 key 值的指针 
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>xv</span><span class=p>,</span> <span class=nx>yv</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 指向 x 和 y 的 value 值的指针  
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 新桶中低位的一些桶
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>x</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>oldbucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>		<span class=nx>xi</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 扩容以后的新桶中低位的第一个 key 值
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>xk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>x</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 扩容以后的新桶中低位的第一个 key 值对应的 value 值
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>xv</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>xk</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 如果不是等量扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>sameSizeGrow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>y</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=p>(</span><span class=nx>oldbucket</span><span class=o>+</span><span class=nx>newbit</span><span class=p>)</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>			<span class=nx>yi</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>			<span class=nx>yk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>y</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>yv</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>yk</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 依次遍历溢出桶
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=p>;</span> <span class=nx>b</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>b</span> <span class=p>=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>overflow</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>k</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>v</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 遍历 key - value 键值对
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>bucketCnt</span><span class=p>;</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=p>=</span> <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nf>add</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>)),</span> <span class=nf>add</span><span class=p>(</span><span class=nx>v</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>valuesize</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>top</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>top</span> <span class=o>==</span> <span class=nx>empty</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>evacuatedEmpty</span>
</span></span><span class=line><span class=cl>					<span class=k>continue</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>top</span> <span class=p>&lt;</span> <span class=nx>minTopHash</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;bad map state&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>k2</span> <span class=o>:=</span> <span class=nx>k</span>
</span></span><span class=line><span class=cl>				<span class=c1>// key 值如果是指针，则取出指针里面的值
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nx>indirectkey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>k2</span> <span class=p>=</span> <span class=o>*</span><span class=p>((</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>k2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>useX</span> <span class=o>:=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>sameSizeGrow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 如果不是等量扩容，则需要重新计算 hash 值，不管是高位桶 x 中，还是低位桶 y 中
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=nx>hash</span> <span class=o>:=</span> <span class=nx>alg</span><span class=p>.</span><span class=nf>hash</span><span class=p>(</span><span class=nx>k2</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>iterator</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=k>if</span> <span class=p>!</span><span class=nx>t</span><span class=p>.</span><span class=nx>reflexivekey</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>alg</span><span class=p>.</span><span class=nf>equal</span><span class=p>(</span><span class=nx>k2</span><span class=p>,</span> <span class=nx>k2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>							<span class=c1>// 如果两个 key 不相等，那么他们俩极大可能旧的 hash 值也不相等。
</span></span></span><span class=line><span class=cl><span class=c1></span>							<span class=c1>// tophash 对要迁移的 key 值也是没有多大意义的，所以我们用低位的 tophash 辅助扩容，标记一些状态。
</span></span></span><span class=line><span class=cl><span class=c1></span>							<span class=c1>// 为下一个级 level 重新计算一些新的随机的 hash 值。以至于这些 key 值在多次扩容以后依旧可以均匀分布在所有桶中
</span></span></span><span class=line><span class=cl><span class=c1></span>							<span class=c1>// 判断 top 的最低位是否为1
</span></span></span><span class=line><span class=cl><span class=c1></span>							<span class=k>if</span> <span class=nx>top</span><span class=o>&amp;</span><span class=mi>1</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>								<span class=nx>hash</span> <span class=o>|=</span> <span class=nx>newbit</span>
</span></span><span class=line><span class=cl>							<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>								<span class=nx>hash</span> <span class=o>&amp;^=</span> <span class=nx>newbit</span>
</span></span><span class=line><span class=cl>							<span class=p>}</span>
</span></span><span class=line><span class=cl>							<span class=nx>top</span> <span class=p>=</span> <span class=nb>uint8</span><span class=p>(</span><span class=nx>hash</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=nx>sys</span><span class=p>.</span><span class=nx>PtrSize</span><span class=o>*</span><span class=mi>8</span> <span class=o>-</span> <span class=mi>8</span><span class=p>))</span>
</span></span><span class=line><span class=cl>							<span class=k>if</span> <span class=nx>top</span> <span class=p>&lt;</span> <span class=nx>minTopHash</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>								<span class=nx>top</span> <span class=o>+=</span> <span class=nx>minTopHash</span>
</span></span><span class=line><span class=cl>							<span class=p>}</span>
</span></span><span class=line><span class=cl>						<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=nx>useX</span> <span class=p>=</span> <span class=nx>hash</span><span class=o>&amp;</span><span class=nx>newbit</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>useX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 标记低位桶存在 tophash 中
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>evacuatedX</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 如果 key 的索引值到了桶最后一个，就新建一个 overflow
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=k>if</span> <span class=nx>xi</span> <span class=o>==</span> <span class=nx>bucketCnt</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nx>newx</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nf>newoverflow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>						<span class=nx>x</span> <span class=p>=</span> <span class=nx>newx</span>
</span></span><span class=line><span class=cl>						<span class=nx>xi</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>						<span class=nx>xk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>x</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>						<span class=nx>xv</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>xk</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 把 hash 的高8位再次存在 tophash 中
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=nx>x</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>xi</span><span class=p>]</span> <span class=p>=</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nx>indirectkey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=c1>// 如果是指针指向 key ，那么拷贝指针指向
</span></span></span><span class=line><span class=cl><span class=c1></span>						<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>xk</span><span class=p>)</span> <span class=p>=</span> <span class=nx>k2</span> <span class=c1>// copy pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=c1>// 如果是指针指向 key ，那么进行值拷贝
</span></span></span><span class=line><span class=cl><span class=c1></span>						<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>xk</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span> <span class=c1>// copy value
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 同理拷贝 value
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nx>indirectvalue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>xv</span><span class=p>)</span> <span class=p>=</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>elem</span><span class=p>,</span> <span class=nx>xv</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 继续迁移下一个
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=nx>xi</span><span class=o>++</span>
</span></span><span class=line><span class=cl>					<span class=nx>xk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>xk</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>					<span class=nx>xv</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>xv</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>valuesize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 这里是高位桶 y，迁移过程和上述低位桶 x 一致，下面就不再赘述了
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>evacuatedY</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=nx>yi</span> <span class=o>==</span> <span class=nx>bucketCnt</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nx>newy</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nf>newoverflow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>						<span class=nx>y</span> <span class=p>=</span> <span class=nx>newy</span>
</span></span><span class=line><span class=cl>						<span class=nx>yi</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>						<span class=nx>yk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>y</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>						<span class=nx>yv</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>yk</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=nx>y</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>yi</span><span class=p>]</span> <span class=p>=</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nx>indirectkey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>yk</span><span class=p>)</span> <span class=p>=</span> <span class=nx>k2</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>yk</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nx>indirectvalue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>yv</span><span class=p>)</span> <span class=p>=</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>elem</span><span class=p>,</span> <span class=nx>yv</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=nx>yi</span><span class=o>++</span>
</span></span><span class=line><span class=cl>					<span class=nx>yk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>yk</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>					<span class=nx>yv</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>yv</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>valuesize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Unlink the overflow buckets &amp; clear key/value to help GC.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>oldIterator</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>b</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span><span class=p>,</span> <span class=nx>oldbucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Preserve b.tophash because the evacuation
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// state is maintained there.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nx>bucket</span><span class=p>.</span><span class=nx>kind</span><span class=o>&amp;</span><span class=nx>kindNoPointers</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>memclrHasPointers</span><span class=p>(</span><span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>),</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)</span><span class=o>-</span><span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>memclrNoHeapPointers</span><span class=p>(</span><span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>),</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)</span><span class=o>-</span><span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Advance evacuation mark
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>oldbucket</span> <span class=o>==</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=p>=</span> <span class=nx>oldbucket</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Experiments suggest that 1024 is overkill by at least an order of magnitude.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Put it in there as a safeguard anyway, to ensure O(1) behavior.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>stop</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=o>+</span> <span class=mi>1024</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>stop</span> <span class=p>&gt;</span> <span class=nx>newbit</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>stop</span> <span class=p>=</span> <span class=nx>newbit</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=o>!=</span> <span class=nx>stop</span> <span class=o>&amp;&amp;</span> <span class=nf>bucketEvacuated</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=o>==</span> <span class=nx>newbit</span> <span class=p>{</span> <span class=c1>// newbit == # of oldbuckets
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// Growing is all done. Free old main bucket array.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Can discard old overflow buckets as well.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// If they are still referenced by an iterator,
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// then the iterator holds a pointers to the slice.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>&amp;^=</span> <span class=nx>sameSizeGrow</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果未迁移完毕，赋值/删除的时候，扩容完毕后（预分配内存），不会马上就进行迁移。而是采取增量扩容的方式，当有访问到具体 bukcet 时，才会逐渐的进行迁移（将 oldbucket 迁移到 bucket）</p><h3 id=迁移函数>迁移函数</h3><p><code>hmap.nevacuate</code> 标识的是当前的进度，如果都搬迁完，应该和 2^B 的长度是一样的
在 evacuate 方法实现是把这个位置对应的 bucket，以及其冲突链上的数据都转移到新的 bucket 上。</p><ol><li><p>先要判断当前 bucket 是不是已经转移。 (oldbucket 标识需要搬迁的 bucket 对应的位置)。转移的判断直接通过 tophash 就可以，判断 tophash 中第一个 hash 值即可</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>emptyOne</span>       <span class=p>=</span> <span class=mi>1</span> <span class=c1>// this cell is empty
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>minTopHash</span>     <span class=p>=</span> <span class=mi>5</span> <span class=c1>// minimum tophash for a normal filled cell.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>evacuated</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>bmap</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>h</span> <span class=p>&gt;</span> <span class=nx>emptyOne</span> <span class=o>&amp;&amp;</span> <span class=nx>h</span> <span class=p>&lt;</span> <span class=nx>minTopHash</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>如果没有被转移，那就要迁移数据了。数据迁移时，可能是迁移到大小相同的 buckets 上，也可能迁移到2倍大的 buckets 上。这里 xy 都是标记目标迁移位置的标记：x 标识的是迁移到相同的位置，y 标识的是迁移到2倍大的位置上。我们先看下目标位置的确定：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>xy</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=nx>evacDst</span>
</span></span><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>xy</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>x</span><span class=p>.</span><span class=nx>b</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>oldbucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=nx>x</span><span class=p>.</span><span class=nx>k</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>x</span><span class=p>.</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>x</span><span class=p>.</span><span class=nx>e</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>x</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>sameSizeGrow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Only calculate y pointers if we&#39;re growing bigger.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Otherwise GC can see bad pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>y</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>xy</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>y</span><span class=p>.</span><span class=nx>b</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=p>(</span><span class=nx>oldbucket</span><span class=o>+</span><span class=nx>newbit</span><span class=p>)</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>y</span><span class=p>.</span><span class=nx>k</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>y</span><span class=p>.</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>y</span><span class=p>.</span><span class=nx>e</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>y</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>确定bucket位置后，需要按照kv 一条一条做迁移。</p></li><li><p>如果当前搬迁的 bucket 和 总体搬迁的 bucket 的位置是一样的，我们需要更新总体进度的标记 nevacuate</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>advanceEvacuationMark</span><span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>newbit</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Experiments suggest that 1024 is overkill by at least an order of magnitude.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Put it in there as a safeguard anyway, to ensure O(1) behavior.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>stop</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=o>+</span> <span class=mi>1024</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>stop</span> <span class=p>&gt;</span> <span class=nx>newbit</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>stop</span> <span class=p>=</span> <span class=nx>newbit</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=o>!=</span> <span class=nx>stop</span> <span class=o>&amp;&amp;</span> <span class=nf>bucketEvacuated</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=o>==</span> <span class=nx>newbit</span> <span class=p>{</span> <span class=c1>// newbit == # of oldbuckets
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Growing is all done. Free old main bucket array.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Can discard old overflow buckets as well.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// If they are still referenced by an iterator,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// then the iterator holds a pointers to the slice.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>oldoverflow</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>&amp;^=</span> <span class=nx>sameSizeGrow</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h2 id=总结>总结</h2><ul><li>map是引用类型</li><li>map遍历是无序的</li><li>map是非线程安全的</li><li>map的哈希冲突解决方式是链表法</li><li>map的扩容不是一定会新增空间，也有可能是只是做了内存整理</li><li>map的迁移是逐步进行的，在每次赋值时，会做至少一次迁移工作</li><li>map中删除 key，有可能导致出现很多空的 kv，这会导致迁移操作，如果可以避免，尽量避免</li></ul><h3 id=参考>参考</h3><ul><li><a class=link href=https://www.cnblogs.com/cnblogs-wangzhipeng/p/13292524.html target=_blank rel=noopener>https://www.cnblogs.com/cnblogs-wangzhipeng/p/13292524.html</a></li><li><a class=link href=https://halfrost.com/go_map_chapter_one/ target=_blank rel=noopener>https://halfrost.com/go_map_chapter_one/</a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/golang/>Golang</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/golang-gmp/><div class=article-details><h2 class=article-title>Golang GMP</h2></div></a></article><article><a href=/p/golang-slice/><div class=article-details><h2 class=article-title>Golang Slice</h2></div></a></article><article><a href=/p/gin-opentracing%E7%9A%84%E4%BD%BF%E7%94%A8/><div class=article-details><h2 class=article-title>gin+opentracing的使用</h2></div></a></article><article><a href=/p/%E4%BD%BF%E7%94%A8-map-%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98/><div class=article-details><h2 class=article-title>使用 map 设计缓存</h2></div></a></article><article><a href=/p/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BDbug/><div class=article-details><h2 class=article-title>文件下载Bug</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 Trock</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>